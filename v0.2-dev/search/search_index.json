{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Frequenz Client Base Library","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Utilities for writing Frequenz API clients</p>"},{"location":"#supported-platforms","title":"Supported Platforms","text":"<p>The following platforms are officially supported (tested):</p> <ul> <li>Python: 3.11</li> <li>Operating System: Ubuntu Linux 20.04</li> <li>Architectures: amd64, arm64</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to know how to build this project and contribute to it, please check out the Contributing Guide.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Frequenz Client Base Library","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"CONTRIBUTING/#cross-arch-testing","title":"Cross-Arch Testing","text":"<p>This project has built-in support for testing across multiple architectures. Currently, our CI conducts tests on <code>arm64</code> machines using QEMU emulation. We also have the flexibility to expand this support to include additional architectures in the future.</p> <p>This project contains Dockerfiles that can be used in the CI to test the python package in non-native machine architectures, e.g., <code>arm64</code>. The Dockerfiles exist in the directory <code>.github/containers/nox-cross-arch</code>, and follow a naming scheme so that they can be easily used in build matrices in the CI, in <code>nox-cross-arch</code> job. The naming scheme is:</p> <pre><code>&lt;arch&gt;-&lt;os&gt;-python-&lt;python-version&gt;.Dockerfile\n</code></pre> <p>E.g.,</p> <pre><code>arm64-ubuntu-20.04-python-3.11.Dockerfile\n</code></pre> <p>If a Dockerfile for your desired target architecture, OS, and python version does not exist here, please add one before proceeding to add your options to the test matrix.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>client<ul> <li>base<ul> <li>channel</li> <li>client</li> <li>conversion</li> <li>exception</li> <li>retry</li> <li>streaming</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/frequenz/client/base/","title":"Index","text":""},{"location":"reference/frequenz/client/base/#frequenz.client.base","title":"frequenz.client.base","text":"<p>Utilities for writing Frequenz API clients.</p>"},{"location":"reference/frequenz/client/base/channel/","title":"channel","text":""},{"location":"reference/frequenz/client/base/channel/#frequenz.client.base.channel","title":"frequenz.client.base.channel","text":"<p>Handling of gRPC channels.</p>"},{"location":"reference/frequenz/client/base/channel/#frequenz.client.base.channel-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/base/channel/#frequenz.client.base.channel.ChannelT","title":"frequenz.client.base.channel.ChannelT  <code>module-attribute</code>","text":"<pre><code>ChannelT = TypeVar(\n    \"ChannelT\", bound=AsyncContextManager[Any]\n)\n</code></pre> <p>A <code>grpclib</code> or <code>grpcio</code> channel type.</p>"},{"location":"reference/frequenz/client/base/channel/#frequenz.client.base.channel-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/channel/#frequenz.client.base.channel.parse_grpc_uri","title":"frequenz.client.base.channel.parse_grpc_uri","text":"<pre><code>parse_grpc_uri(\n    uri: str,\n    channel_type: type[ChannelT],\n    /,\n    *,\n    default_port: int = 9090,\n) -&gt; ChannelT\n</code></pre> <p>Create a grpclib client channel from a URI.</p> <p>The URI must have the following format:</p> <pre><code>grpc://hostname[:port][?ssl=false]\n</code></pre> <p>A few things to consider about URI components:</p> <ul> <li>If any other components are present in the URI, a <code>ValueError</code> is raised.</li> <li>If the port is omitted, the <code>default_port</code> is used.</li> <li>If a query parameter is passed many times, the last value is used.</li> <li>The only supported query parameter is <code>ssl</code>, which must be a boolean value and   defaults to <code>false</code>.</li> <li>Boolean query parameters can be specified with the following values   (case-insensitive): <code>true</code>, <code>1</code>, <code>on</code>, <code>false</code>, <code>0</code>, <code>off</code>.</li> </ul> PARAMETER DESCRIPTION <code>uri</code> <p>The gRPC URI specifying the connection parameters.</p> <p> TYPE: <code>str</code> </p> <code>channel_type</code> <p>The type of channel to create.</p> <p> TYPE: <code>type[ChannelT]</code> </p> <code>default_port</code> <p>The default port number to use if the URI does not specify one.</p> <p> TYPE: <code>int</code> DEFAULT: <code>9090</code> </p> RETURNS DESCRIPTION <code>ChannelT</code> <p>A grpclib client channel object.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the URI is invalid or contains unexpected components.</p> Source code in <code>frequenz/client/base/channel.py</code> <pre><code>def parse_grpc_uri(\n    uri: str, channel_type: type[ChannelT], /, *, default_port: int = 9090\n) -&gt; ChannelT:\n    \"\"\"Create a grpclib client channel from a URI.\n\n    The URI must have the following format:\n\n    ```\n    grpc://hostname[:port][?ssl=false]\n    ```\n\n    A few things to consider about URI components:\n\n    - If any other components are present in the URI, a [`ValueError`][] is raised.\n    - If the port is omitted, the `default_port` is used.\n    - If a query parameter is passed many times, the last value is used.\n    - The only supported query parameter is `ssl`, which must be a boolean value and\n      defaults to `false`.\n    - Boolean query parameters can be specified with the following values\n      (case-insensitive): `true`, `1`, `on`, `false`, `0`, `off`.\n\n    Args:\n        uri: The gRPC URI specifying the connection parameters.\n        channel_type: The type of channel to create.\n        default_port: The default port number to use if the URI does not specify one.\n\n    Returns:\n        A grpclib client channel object.\n\n    Raises:\n        ValueError: If the URI is invalid or contains unexpected components.\n    \"\"\"\n    parsed_uri = urlparse(uri)\n    if parsed_uri.scheme != \"grpc\":\n        raise ValueError(\n            f\"Invalid scheme '{parsed_uri.scheme}' in the URI, expected 'grpc'\", uri\n        )\n    if not parsed_uri.hostname:\n        raise ValueError(f\"Host name is missing in URI '{uri}'\", uri)\n    for attr in (\"path\", \"fragment\", \"params\", \"username\", \"password\"):\n        if getattr(parsed_uri, attr):\n            raise ValueError(\n                f\"Unexpected {attr} '{getattr(parsed_uri, attr)}' in the URI '{uri}'\",\n                uri,\n            )\n\n    options = {k: v[-1] for k, v in parse_qs(parsed_uri.query).items()}\n    ssl = _to_bool(options.pop(\"ssl\", \"false\"))\n    if options:\n        raise ValueError(\n            f\"Unexpected query parameters {options!r} in the URI '{uri}'\",\n            uri,\n        )\n\n    host = parsed_uri.hostname\n    port = parsed_uri.port or default_port\n    match channel_type:\n        case _grpchacks.GrpcioChannel:\n            return cast(ChannelT, _grpchacks.grpcio_create_channel(host, port, ssl))\n        case _grpchacks.GrpclibChannel:\n            return cast(ChannelT, _grpchacks.grpclib_create_channel(host, port, ssl))\n    assert False, \"Unexpected channel type: {channel_type}\"\n</code></pre>"},{"location":"reference/frequenz/client/base/client/","title":"client","text":""},{"location":"reference/frequenz/client/base/client/#frequenz.client.base.client","title":"frequenz.client.base.client","text":"<p>Base class for API clients.</p>"},{"location":"reference/frequenz/client/base/client/#frequenz.client.base.client-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/base/client/#frequenz.client.base.client-classes","title":"Classes","text":""},{"location":"reference/frequenz/client/base/client/#frequenz.client.base.client.BaseApiClient","title":"frequenz.client.base.client.BaseApiClient","text":"<p>               Bases: <code>ABC</code>, <code>Generic[StubT, ChannelT]</code></p> <p>A base class for API clients.</p> <p>This class provides a common interface for API clients that communicate with a API server. It is designed to be subclassed by specific API clients that provide a more specific interface.</p> Source code in <code>frequenz/client/base/client.py</code> <pre><code>class BaseApiClient(abc.ABC, Generic[StubT, ChannelT]):\n    \"\"\"A base class for API clients.\n\n    This class provides a common interface for API clients that communicate with a API\n    server. It is designed to be subclassed by specific API clients that provide a more\n    specific interface.\n    \"\"\"\n\n    def __init__(\n        self,\n        server_url: str,\n        create_stub: Callable[[ChannelT], StubT],\n        channel_type: type[ChannelT],\n        *,\n        auto_connect: bool = True,\n    ) -&gt; None:\n        \"\"\"Create an instance and connect to the server.\n\n        Args:\n            server_url: The URL of the server to connect to.\n            create_stub: A function that creates a stub from a channel.\n            channel_type: The type of channel to use.\n            auto_connect: Whether to automatically connect to the server. If `False`, the\n                client will not connect to the server until\n                [connect()][frequenz.client.base.client.BaseApiClient.connect] is\n                called.\n        \"\"\"\n        self._server_url: str = server_url\n        self._create_stub: Callable[[ChannelT], StubT] = create_stub\n        self._channel_type: type[ChannelT] = channel_type\n        self._channel: ChannelT | None = None\n        self._stub: StubT | None = None\n        if auto_connect:\n            self.connect(server_url)\n\n    @property\n    def server_url(self) -&gt; str:\n        \"\"\"The URL of the server.\"\"\"\n        return self._server_url\n\n    @property\n    def channel(self) -&gt; ChannelT:\n        \"\"\"The underlying gRPC channel used to communicate with the server.\n\n        Warning:\n            This channel is provided as a last resort for advanced users. It is not\n            recommended to use this property directly unless you know what you are\n            doing and you don't care about being tied to a specific gRPC library.\n\n        Raises:\n            ClientNotConnected: If the client is not connected to the server.\n        \"\"\"\n        if self._channel is None:\n            raise ClientNotConnected(server_url=self.server_url, operation=\"channel\")\n        return self._channel\n\n    @property\n    def stub(self) -&gt; StubT:\n        \"\"\"The underlying gRPC stub.\n\n        Warning:\n            This stub is provided as a last resort for advanced users. It is not\n            recommended to use this property directly unless you know what you are\n            doing and you don't care about being tied to a specific gRPC library.\n\n        Raises:\n            ClientNotConnected: If the client is not connected to the server.\n        \"\"\"\n        if self._stub is None:\n            raise ClientNotConnected(server_url=self.server_url, operation=\"stub\")\n        return self._stub\n\n    @property\n    def is_connected(self) -&gt; bool:\n        \"\"\"Whether the client is connected to the server.\"\"\"\n        return self._channel is not None\n\n    def connect(self, server_url: str | None = None) -&gt; None:\n        \"\"\"Connect to the server, possibly using a new URL.\n\n        If the client is already connected and the URL is the same as the previous URL,\n        this method does nothing. If you want to force a reconnection, you can call\n        [disconnect()][frequenz.client.base.client.BaseApiClient.disconnect] first.\n\n        Args:\n            server_url: The URL of the server to connect to. If not provided, the\n                previously used URL is used.\n        \"\"\"\n        if server_url is not None and server_url != self._server_url:  # URL changed\n            self._server_url = server_url\n        elif self.is_connected:\n            return\n        self._channel = parse_grpc_uri(self._server_url, self._channel_type)\n        self._stub = self._create_stub(self._channel)\n\n    async def disconnect(self) -&gt; None:\n        \"\"\"Disconnect from the server.\n\n        If the client is not connected, this method does nothing.\n        \"\"\"\n        await self.__aexit__(None, None, None)\n\n    async def __aenter__(self) -&gt; Self:\n        \"\"\"Enter a context manager.\"\"\"\n        self.connect()\n        return self\n\n    async def __aexit__(\n        self,\n        _exc_type: type[BaseException] | None,\n        _exc_val: BaseException | None,\n        _exc_tb: Any | None,\n    ) -&gt; bool | None:\n        \"\"\"Exit a context manager.\"\"\"\n        if self._channel is None:\n            return None\n        # We need to ignore the return type here because the __aexit__ method of grpclib\n        # is not annotated correctly, it is annotated to return None but __aexit__\n        # should return a bool | None. This should be harmless if grpclib never handle\n        # any exceptions in __aexit__, so it is just a type checker issue. This is the\n        # error produced by mypy:\n        # Function does not return a value (it only ever returns None)\n        # [func-returns-value]\n        # See https://github.com/vmagamedov/grpclib/issues/193 for more details.\n        result = await self._channel.__aexit__(_exc_type, _exc_val, _exc_tb)\n        self._channel = None\n        self._stub = None\n        return result\n</code></pre>"},{"location":"reference/frequenz/client/base/client/#frequenz.client.base.client.BaseApiClient-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/base/client/#frequenz.client.base.client.BaseApiClient.channel","title":"channel  <code>property</code>","text":"<pre><code>channel: ChannelT\n</code></pre> <p>The underlying gRPC channel used to communicate with the server.</p> Warning <p>This channel is provided as a last resort for advanced users. It is not recommended to use this property directly unless you know what you are doing and you don't care about being tied to a specific gRPC library.</p> RAISES DESCRIPTION <code>ClientNotConnected</code> <p>If the client is not connected to the server.</p>"},{"location":"reference/frequenz/client/base/client/#frequenz.client.base.client.BaseApiClient.is_connected","title":"is_connected  <code>property</code>","text":"<pre><code>is_connected: bool\n</code></pre> <p>Whether the client is connected to the server.</p>"},{"location":"reference/frequenz/client/base/client/#frequenz.client.base.client.BaseApiClient.server_url","title":"server_url  <code>property</code>","text":"<pre><code>server_url: str\n</code></pre> <p>The URL of the server.</p>"},{"location":"reference/frequenz/client/base/client/#frequenz.client.base.client.BaseApiClient.stub","title":"stub  <code>property</code>","text":"<pre><code>stub: StubT\n</code></pre> <p>The underlying gRPC stub.</p> Warning <p>This stub is provided as a last resort for advanced users. It is not recommended to use this property directly unless you know what you are doing and you don't care about being tied to a specific gRPC library.</p> RAISES DESCRIPTION <code>ClientNotConnected</code> <p>If the client is not connected to the server.</p>"},{"location":"reference/frequenz/client/base/client/#frequenz.client.base.client.BaseApiClient-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/client/#frequenz.client.base.client.BaseApiClient.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter a context manager.</p> Source code in <code>frequenz/client/base/client.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"Enter a context manager.\"\"\"\n    self.connect()\n    return self\n</code></pre>"},{"location":"reference/frequenz/client/base/client/#frequenz.client.base.client.BaseApiClient.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    _exc_type: type[BaseException] | None,\n    _exc_val: BaseException | None,\n    _exc_tb: Any | None,\n) -&gt; bool | None\n</code></pre> <p>Exit a context manager.</p> Source code in <code>frequenz/client/base/client.py</code> <pre><code>async def __aexit__(\n    self,\n    _exc_type: type[BaseException] | None,\n    _exc_val: BaseException | None,\n    _exc_tb: Any | None,\n) -&gt; bool | None:\n    \"\"\"Exit a context manager.\"\"\"\n    if self._channel is None:\n        return None\n    # We need to ignore the return type here because the __aexit__ method of grpclib\n    # is not annotated correctly, it is annotated to return None but __aexit__\n    # should return a bool | None. This should be harmless if grpclib never handle\n    # any exceptions in __aexit__, so it is just a type checker issue. This is the\n    # error produced by mypy:\n    # Function does not return a value (it only ever returns None)\n    # [func-returns-value]\n    # See https://github.com/vmagamedov/grpclib/issues/193 for more details.\n    result = await self._channel.__aexit__(_exc_type, _exc_val, _exc_tb)\n    self._channel = None\n    self._stub = None\n    return result\n</code></pre>"},{"location":"reference/frequenz/client/base/client/#frequenz.client.base.client.BaseApiClient.__init__","title":"__init__","text":"<pre><code>__init__(\n    server_url: str,\n    create_stub: Callable[[ChannelT], StubT],\n    channel_type: type[ChannelT],\n    *,\n    auto_connect: bool = True\n) -&gt; None\n</code></pre> <p>Create an instance and connect to the server.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server to connect to.</p> <p> TYPE: <code>str</code> </p> <code>create_stub</code> <p>A function that creates a stub from a channel.</p> <p> TYPE: <code>Callable[[ChannelT], StubT]</code> </p> <code>channel_type</code> <p>The type of channel to use.</p> <p> TYPE: <code>type[ChannelT]</code> </p> <code>auto_connect</code> <p>Whether to automatically connect to the server. If <code>False</code>, the client will not connect to the server until connect() is called.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>frequenz/client/base/client.py</code> <pre><code>def __init__(\n    self,\n    server_url: str,\n    create_stub: Callable[[ChannelT], StubT],\n    channel_type: type[ChannelT],\n    *,\n    auto_connect: bool = True,\n) -&gt; None:\n    \"\"\"Create an instance and connect to the server.\n\n    Args:\n        server_url: The URL of the server to connect to.\n        create_stub: A function that creates a stub from a channel.\n        channel_type: The type of channel to use.\n        auto_connect: Whether to automatically connect to the server. If `False`, the\n            client will not connect to the server until\n            [connect()][frequenz.client.base.client.BaseApiClient.connect] is\n            called.\n    \"\"\"\n    self._server_url: str = server_url\n    self._create_stub: Callable[[ChannelT], StubT] = create_stub\n    self._channel_type: type[ChannelT] = channel_type\n    self._channel: ChannelT | None = None\n    self._stub: StubT | None = None\n    if auto_connect:\n        self.connect(server_url)\n</code></pre>"},{"location":"reference/frequenz/client/base/client/#frequenz.client.base.client.BaseApiClient.connect","title":"connect","text":"<pre><code>connect(server_url: str | None = None) -&gt; None\n</code></pre> <p>Connect to the server, possibly using a new URL.</p> <p>If the client is already connected and the URL is the same as the previous URL, this method does nothing. If you want to force a reconnection, you can call disconnect() first.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server to connect to. If not provided, the previously used URL is used.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/client/base/client.py</code> <pre><code>def connect(self, server_url: str | None = None) -&gt; None:\n    \"\"\"Connect to the server, possibly using a new URL.\n\n    If the client is already connected and the URL is the same as the previous URL,\n    this method does nothing. If you want to force a reconnection, you can call\n    [disconnect()][frequenz.client.base.client.BaseApiClient.disconnect] first.\n\n    Args:\n        server_url: The URL of the server to connect to. If not provided, the\n            previously used URL is used.\n    \"\"\"\n    if server_url is not None and server_url != self._server_url:  # URL changed\n        self._server_url = server_url\n    elif self.is_connected:\n        return\n    self._channel = parse_grpc_uri(self._server_url, self._channel_type)\n    self._stub = self._create_stub(self._channel)\n</code></pre>"},{"location":"reference/frequenz/client/base/client/#frequenz.client.base.client.BaseApiClient.disconnect","title":"disconnect  <code>async</code>","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the server.</p> <p>If the client is not connected, this method does nothing.</p> Source code in <code>frequenz/client/base/client.py</code> <pre><code>async def disconnect(self) -&gt; None:\n    \"\"\"Disconnect from the server.\n\n    If the client is not connected, this method does nothing.\n    \"\"\"\n    await self.__aexit__(None, None, None)\n</code></pre>"},{"location":"reference/frequenz/client/base/client/#frequenz.client.base.client-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/conversion/","title":"conversion","text":""},{"location":"reference/frequenz/client/base/conversion/#frequenz.client.base.conversion","title":"frequenz.client.base.conversion","text":"<p>Helper functions to convert to/from common python types.</p>"},{"location":"reference/frequenz/client/base/conversion/#frequenz.client.base.conversion-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/conversion/#frequenz.client.base.conversion.to_datetime","title":"frequenz.client.base.conversion.to_datetime","text":"<pre><code>to_datetime(\n    ts: Timestamp, tz: timezone = timezone.utc\n) -&gt; datetime\n</code></pre> <p>Convert a protobuf Timestamp to a datetime.</p> PARAMETER DESCRIPTION <code>ts</code> <p>Timestamp object to convert</p> <p> TYPE: <code>Timestamp</code> </p> <code>tz</code> <p>Timezone to use for the datetime</p> <p> TYPE: <code>timezone</code> DEFAULT: <code>utc</code> </p> RETURNS DESCRIPTION <code>datetime</code> <p>Timestamp converted to datetime</p> Source code in <code>frequenz/client/base/conversion.py</code> <pre><code>def to_datetime(ts: Timestamp, tz: timezone = timezone.utc) -&gt; datetime:\n    \"\"\"Convert a protobuf Timestamp to a datetime.\n\n    Args:\n        ts: Timestamp object to convert\n        tz: Timezone to use for the datetime\n\n    Returns:\n        Timestamp converted to datetime\n    \"\"\"\n    # Add microseconds and add nanoseconds converted to microseconds\n    microseconds = int(ts.nanos / 1000)\n    return datetime.fromtimestamp(ts.seconds + microseconds * 1e-6, tz=tz)\n</code></pre>"},{"location":"reference/frequenz/client/base/conversion/#frequenz.client.base.conversion.to_timestamp","title":"frequenz.client.base.conversion.to_timestamp","text":"<pre><code>to_timestamp(dt: datetime | None) -&gt; Timestamp | None\n</code></pre> <p>Convert a datetime to a protobuf Timestamp.</p> <p>Returns None if dt is None.</p> PARAMETER DESCRIPTION <code>dt</code> <p>datetime object to convert</p> <p> TYPE: <code>datetime | None</code> </p> RETURNS DESCRIPTION <code>Timestamp | None</code> <p>datetime converted to Timestamp</p> Source code in <code>frequenz/client/base/conversion.py</code> <pre><code>def to_timestamp(dt: datetime | None) -&gt; Timestamp | None:\n    \"\"\"Convert a datetime to a protobuf Timestamp.\n\n    Returns None if dt is None.\n\n    Args:\n        dt: datetime object to convert\n\n    Returns:\n        datetime converted to Timestamp\n    \"\"\"\n    if dt is None:\n        return None\n\n    ts = Timestamp()\n    ts.FromDatetime(dt)\n    return ts\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/","title":"exception","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception","title":"frequenz.client.base.exception","text":"<p>Exceptions raised by an API client.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception-classes","title":"Classes","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ApiClientError","title":"frequenz.client.base.exception.ApiClientError","text":"<p>               Bases: <code>Exception</code></p> <p>There was an error in an API client.</p> <p>To simplify retrying, errors are classified as retryable, or not. Retryable errors might succeed if retried, while permanent errors won't. When uncertain, errors are assumed to be retryable.</p> <p>The following sub-classes are available:</p> <ul> <li>GrpcError: A gRPC operation failed.</li> </ul> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class ApiClientError(Exception):\n    \"\"\"There was an error in an API client.\n\n    To simplify retrying, errors are classified as\n    [retryable][frequenz.client.base.exception.ApiClientError.is_retryable], or not.\n    Retryable errors might succeed if retried, while permanent errors won't. When\n    uncertain, errors are assumed to be retryable.\n\n    The following sub-classes are available:\n\n    - [GrpcError][frequenz.client.base.exception.GrpcError]: A gRPC operation failed.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        server_url: str,\n        operation: str,\n        description: str,\n        retryable: bool,\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            description: A human-readable description of the error.\n            retryable: Whether retrying the operation might succeed.\n        \"\"\"\n        super().__init__(\n            f\"Failed calling {operation!r} on {server_url!r}: {description}\"\n        )\n\n        self.server_url = server_url\n        \"\"\"The URL of the server that returned the error.\"\"\"\n\n        self.operation = operation\n        \"\"\"The operation that caused the error.\"\"\"\n\n        self.description = description\n        \"\"\"The human-readable description of the error.\"\"\"\n\n        self.is_retryable = retryable\n        \"\"\"Whether retrying the operation might succeed.\"\"\"\n\n    @classmethod\n    def from_grpc_error(\n        cls,\n        *,\n        server_url: str,\n        operation: str,\n        grpc_error: Exception,\n    ) -&gt; GrpcError:\n        \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error to convert.\n\n        Returns:\n            An instance of\n                [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n                is not recognized, or an appropriate subclass if it is.\n        \"\"\"\n\n        class Ctor(Protocol):\n            \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n            def __call__(\n                self, *, server_url: str, operation: str, grpc_error: Exception\n            ) -&gt; GrpcError: ...\n\n        if isinstance(grpc_error, _grpchacks.GrpclibError):\n            import grpclib  # pylint: disable=import-outside-toplevel\n\n            grpclib_status_map: dict[grpclib.Status, Ctor] = {\n                grpclib.Status.CANCELLED: OperationCancelled,\n                grpclib.Status.UNKNOWN: UnknownError,\n                grpclib.Status.INVALID_ARGUMENT: InvalidArgument,\n                grpclib.Status.DEADLINE_EXCEEDED: OperationTimedOut,\n                grpclib.Status.NOT_FOUND: EntityNotFound,\n                grpclib.Status.ALREADY_EXISTS: EntityAlreadyExists,\n                grpclib.Status.PERMISSION_DENIED: PermissionDenied,\n                grpclib.Status.RESOURCE_EXHAUSTED: ResourceExhausted,\n                grpclib.Status.FAILED_PRECONDITION: OperationPreconditionFailed,\n                grpclib.Status.ABORTED: OperationAborted,\n                grpclib.Status.OUT_OF_RANGE: OperationOutOfRange,\n                grpclib.Status.UNIMPLEMENTED: OperationNotImplemented,\n                grpclib.Status.INTERNAL: InternalError,\n                grpclib.Status.UNAVAILABLE: ServiceUnavailable,\n                grpclib.Status.DATA_LOSS: DataLoss,\n                grpclib.Status.UNAUTHENTICATED: OperationUnauthenticated,\n            }\n\n            if ctor := grpclib_status_map.get(grpc_error.status):\n                return ctor(\n                    server_url=server_url, operation=operation, grpc_error=grpc_error\n                )\n        elif isinstance(grpc_error, _grpchacks.GrpcioError):\n            import grpc  # pylint: disable=import-outside-toplevel\n\n            grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n                grpc.StatusCode.CANCELLED: OperationCancelled,\n                grpc.StatusCode.UNKNOWN: UnknownError,\n                grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n                grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n                grpc.StatusCode.NOT_FOUND: EntityNotFound,\n                grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n                grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n                grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n                grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n                grpc.StatusCode.ABORTED: OperationAborted,\n                grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n                grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n                grpc.StatusCode.INTERNAL: InternalError,\n                grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n                grpc.StatusCode.DATA_LOSS: DataLoss,\n                grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n            }\n\n            if ctor := grpc_status_map.get(grpc_error.code()):\n                return ctor(\n                    server_url=server_url, operation=operation, grpc_error=grpc_error\n                )\n        return UnrecognizedGrpcStatus(\n            server_url=server_url,\n            operation=operation,\n            grpc_error=grpc_error,\n        )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ApiClientError-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ApiClientError.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ApiClientError.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ApiClientError.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ApiClientError.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ApiClientError-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ApiClientError.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    description: str,\n    retryable: bool\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>description</code> <p>A human-readable description of the error.</p> <p> TYPE: <code>str</code> </p> <code>retryable</code> <p>Whether retrying the operation might succeed.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self,\n    *,\n    server_url: str,\n    operation: str,\n    description: str,\n    retryable: bool,\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        description: A human-readable description of the error.\n        retryable: Whether retrying the operation might succeed.\n    \"\"\"\n    super().__init__(\n        f\"Failed calling {operation!r} on {server_url!r}: {description}\"\n    )\n\n    self.server_url = server_url\n    \"\"\"The URL of the server that returned the error.\"\"\"\n\n    self.operation = operation\n    \"\"\"The operation that caused the error.\"\"\"\n\n    self.description = description\n    \"\"\"The human-readable description of the error.\"\"\"\n\n    self.is_retryable = retryable\n    \"\"\"Whether retrying the operation might succeed.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ApiClientError.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>Exception</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: Exception\n        ) -&gt; GrpcError: ...\n\n    if isinstance(grpc_error, _grpchacks.GrpclibError):\n        import grpclib  # pylint: disable=import-outside-toplevel\n\n        grpclib_status_map: dict[grpclib.Status, Ctor] = {\n            grpclib.Status.CANCELLED: OperationCancelled,\n            grpclib.Status.UNKNOWN: UnknownError,\n            grpclib.Status.INVALID_ARGUMENT: InvalidArgument,\n            grpclib.Status.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpclib.Status.NOT_FOUND: EntityNotFound,\n            grpclib.Status.ALREADY_EXISTS: EntityAlreadyExists,\n            grpclib.Status.PERMISSION_DENIED: PermissionDenied,\n            grpclib.Status.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpclib.Status.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpclib.Status.ABORTED: OperationAborted,\n            grpclib.Status.OUT_OF_RANGE: OperationOutOfRange,\n            grpclib.Status.UNIMPLEMENTED: OperationNotImplemented,\n            grpclib.Status.INTERNAL: InternalError,\n            grpclib.Status.UNAVAILABLE: ServiceUnavailable,\n            grpclib.Status.DATA_LOSS: DataLoss,\n            grpclib.Status.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpclib_status_map.get(grpc_error.status):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    elif isinstance(grpc_error, _grpchacks.GrpcioError):\n        import grpc  # pylint: disable=import-outside-toplevel\n\n        grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n            grpc.StatusCode.CANCELLED: OperationCancelled,\n            grpc.StatusCode.UNKNOWN: UnknownError,\n            grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n            grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpc.StatusCode.NOT_FOUND: EntityNotFound,\n            grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n            grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n            grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpc.StatusCode.ABORTED: OperationAborted,\n            grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n            grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n            grpc.StatusCode.INTERNAL: InternalError,\n            grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n            grpc.StatusCode.DATA_LOSS: DataLoss,\n            grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpc_status_map.get(grpc_error.code()):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ClientNotConnected","title":"frequenz.client.base.exception.ClientNotConnected","text":"<p>               Bases: <code>ApiClientError</code></p> <p>The client is not connected to the server.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class ClientNotConnected(ApiClientError):\n    \"\"\"The client is not connected to the server.\"\"\"\n\n    def __init__(self, *, server_url: str, operation: str) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"The client is not connected to the server\",\n            retryable=True,\n        )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ClientNotConnected-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ClientNotConnected.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ClientNotConnected.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ClientNotConnected.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ClientNotConnected.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ClientNotConnected-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ClientNotConnected.__init__","title":"__init__","text":"<pre><code>__init__(*, server_url: str, operation: str) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(self, *, server_url: str, operation: str) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"The client is not connected to the server\",\n        retryable=True,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ClientNotConnected.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>Exception</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: Exception\n        ) -&gt; GrpcError: ...\n\n    if isinstance(grpc_error, _grpchacks.GrpclibError):\n        import grpclib  # pylint: disable=import-outside-toplevel\n\n        grpclib_status_map: dict[grpclib.Status, Ctor] = {\n            grpclib.Status.CANCELLED: OperationCancelled,\n            grpclib.Status.UNKNOWN: UnknownError,\n            grpclib.Status.INVALID_ARGUMENT: InvalidArgument,\n            grpclib.Status.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpclib.Status.NOT_FOUND: EntityNotFound,\n            grpclib.Status.ALREADY_EXISTS: EntityAlreadyExists,\n            grpclib.Status.PERMISSION_DENIED: PermissionDenied,\n            grpclib.Status.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpclib.Status.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpclib.Status.ABORTED: OperationAborted,\n            grpclib.Status.OUT_OF_RANGE: OperationOutOfRange,\n            grpclib.Status.UNIMPLEMENTED: OperationNotImplemented,\n            grpclib.Status.INTERNAL: InternalError,\n            grpclib.Status.UNAVAILABLE: ServiceUnavailable,\n            grpclib.Status.DATA_LOSS: DataLoss,\n            grpclib.Status.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpclib_status_map.get(grpc_error.status):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    elif isinstance(grpc_error, _grpchacks.GrpcioError):\n        import grpc  # pylint: disable=import-outside-toplevel\n\n        grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n            grpc.StatusCode.CANCELLED: OperationCancelled,\n            grpc.StatusCode.UNKNOWN: UnknownError,\n            grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n            grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpc.StatusCode.NOT_FOUND: EntityNotFound,\n            grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n            grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n            grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpc.StatusCode.ABORTED: OperationAborted,\n            grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n            grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n            grpc.StatusCode.INTERNAL: InternalError,\n            grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n            grpc.StatusCode.DATA_LOSS: DataLoss,\n            grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpc_status_map.get(grpc_error.code()):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.DataLoss","title":"frequenz.client.base.exception.DataLoss","text":"<p>               Bases: <code>GrpcError</code></p> <p>Unrecoverable data loss or corruption.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class DataLoss(GrpcError):\n    \"\"\"Unrecoverable data loss or corruption.\"\"\"\n\n    def __init__(\n        self, *, server_url: str, operation: str, grpc_error: Exception\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error originating this exception.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"Unrecoverable data loss or corruption\",\n            grpc_error=grpc_error,\n            retryable=False,\n        )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.DataLoss-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.DataLoss.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.DataLoss.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error = grpc_error\n</code></pre> <p>The original gRPC error.</p> <p>This is either a <code>grpclib.GRPCError</code> or a <code>grpc.aio.AioRpcError</code> depending on which library is used. We can't type this correctly if we want this library to work when only one of the libraries is installed.</p> Tip <p>If you need to get this error for a particular library, use the appropriate property:</p> <ul> <li>grpclib_error   for <code>grpclib.GRPCError</code></li> <li>grpcio_error for   <code>grpc.aio.AioRpcError</code></li> </ul>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.DataLoss.grpcio_error","title":"grpcio_error  <code>property</code>","text":"<pre><code>grpcio_error: GrpcioError\n</code></pre> <p>The original <code>grpc.aio.AioRpcError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.DataLoss.grpclib_error","title":"grpclib_error  <code>property</code>","text":"<pre><code>grpclib_error: GrpclibError\n</code></pre> <p>The original <code>grpclib.GRPCError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.DataLoss.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.DataLoss.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.DataLoss.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.DataLoss-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.DataLoss.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>Exception</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self, *, server_url: str, operation: str, grpc_error: Exception\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error originating this exception.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"Unrecoverable data loss or corruption\",\n        grpc_error=grpc_error,\n        retryable=False,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.DataLoss.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>Exception</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: Exception\n        ) -&gt; GrpcError: ...\n\n    if isinstance(grpc_error, _grpchacks.GrpclibError):\n        import grpclib  # pylint: disable=import-outside-toplevel\n\n        grpclib_status_map: dict[grpclib.Status, Ctor] = {\n            grpclib.Status.CANCELLED: OperationCancelled,\n            grpclib.Status.UNKNOWN: UnknownError,\n            grpclib.Status.INVALID_ARGUMENT: InvalidArgument,\n            grpclib.Status.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpclib.Status.NOT_FOUND: EntityNotFound,\n            grpclib.Status.ALREADY_EXISTS: EntityAlreadyExists,\n            grpclib.Status.PERMISSION_DENIED: PermissionDenied,\n            grpclib.Status.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpclib.Status.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpclib.Status.ABORTED: OperationAborted,\n            grpclib.Status.OUT_OF_RANGE: OperationOutOfRange,\n            grpclib.Status.UNIMPLEMENTED: OperationNotImplemented,\n            grpclib.Status.INTERNAL: InternalError,\n            grpclib.Status.UNAVAILABLE: ServiceUnavailable,\n            grpclib.Status.DATA_LOSS: DataLoss,\n            grpclib.Status.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpclib_status_map.get(grpc_error.status):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    elif isinstance(grpc_error, _grpchacks.GrpcioError):\n        import grpc  # pylint: disable=import-outside-toplevel\n\n        grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n            grpc.StatusCode.CANCELLED: OperationCancelled,\n            grpc.StatusCode.UNKNOWN: UnknownError,\n            grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n            grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpc.StatusCode.NOT_FOUND: EntityNotFound,\n            grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n            grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n            grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpc.StatusCode.ABORTED: OperationAborted,\n            grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n            grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n            grpc.StatusCode.INTERNAL: InternalError,\n            grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n            grpc.StatusCode.DATA_LOSS: DataLoss,\n            grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpc_status_map.get(grpc_error.code()):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.EntityAlreadyExists","title":"frequenz.client.base.exception.EntityAlreadyExists","text":"<p>               Bases: <code>GrpcError</code></p> <p>The entity that we attempted to create already exists.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class EntityAlreadyExists(GrpcError):\n    \"\"\"The entity that we attempted to create already exists.\"\"\"\n\n    def __init__(\n        self, *, server_url: str, operation: str, grpc_error: Exception\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error originating this exception.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"The entity that we attempted to create already exists\",\n            grpc_error=grpc_error,\n            retryable=True,  # If the entity is deleted later it might succeed\n        )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.EntityAlreadyExists-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.EntityAlreadyExists.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.EntityAlreadyExists.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error = grpc_error\n</code></pre> <p>The original gRPC error.</p> <p>This is either a <code>grpclib.GRPCError</code> or a <code>grpc.aio.AioRpcError</code> depending on which library is used. We can't type this correctly if we want this library to work when only one of the libraries is installed.</p> Tip <p>If you need to get this error for a particular library, use the appropriate property:</p> <ul> <li>grpclib_error   for <code>grpclib.GRPCError</code></li> <li>grpcio_error for   <code>grpc.aio.AioRpcError</code></li> </ul>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.EntityAlreadyExists.grpcio_error","title":"grpcio_error  <code>property</code>","text":"<pre><code>grpcio_error: GrpcioError\n</code></pre> <p>The original <code>grpc.aio.AioRpcError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.EntityAlreadyExists.grpclib_error","title":"grpclib_error  <code>property</code>","text":"<pre><code>grpclib_error: GrpclibError\n</code></pre> <p>The original <code>grpclib.GRPCError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.EntityAlreadyExists.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.EntityAlreadyExists.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.EntityAlreadyExists.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.EntityAlreadyExists-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.EntityAlreadyExists.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>Exception</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self, *, server_url: str, operation: str, grpc_error: Exception\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error originating this exception.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"The entity that we attempted to create already exists\",\n        grpc_error=grpc_error,\n        retryable=True,  # If the entity is deleted later it might succeed\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.EntityAlreadyExists.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>Exception</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: Exception\n        ) -&gt; GrpcError: ...\n\n    if isinstance(grpc_error, _grpchacks.GrpclibError):\n        import grpclib  # pylint: disable=import-outside-toplevel\n\n        grpclib_status_map: dict[grpclib.Status, Ctor] = {\n            grpclib.Status.CANCELLED: OperationCancelled,\n            grpclib.Status.UNKNOWN: UnknownError,\n            grpclib.Status.INVALID_ARGUMENT: InvalidArgument,\n            grpclib.Status.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpclib.Status.NOT_FOUND: EntityNotFound,\n            grpclib.Status.ALREADY_EXISTS: EntityAlreadyExists,\n            grpclib.Status.PERMISSION_DENIED: PermissionDenied,\n            grpclib.Status.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpclib.Status.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpclib.Status.ABORTED: OperationAborted,\n            grpclib.Status.OUT_OF_RANGE: OperationOutOfRange,\n            grpclib.Status.UNIMPLEMENTED: OperationNotImplemented,\n            grpclib.Status.INTERNAL: InternalError,\n            grpclib.Status.UNAVAILABLE: ServiceUnavailable,\n            grpclib.Status.DATA_LOSS: DataLoss,\n            grpclib.Status.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpclib_status_map.get(grpc_error.status):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    elif isinstance(grpc_error, _grpchacks.GrpcioError):\n        import grpc  # pylint: disable=import-outside-toplevel\n\n        grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n            grpc.StatusCode.CANCELLED: OperationCancelled,\n            grpc.StatusCode.UNKNOWN: UnknownError,\n            grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n            grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpc.StatusCode.NOT_FOUND: EntityNotFound,\n            grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n            grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n            grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpc.StatusCode.ABORTED: OperationAborted,\n            grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n            grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n            grpc.StatusCode.INTERNAL: InternalError,\n            grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n            grpc.StatusCode.DATA_LOSS: DataLoss,\n            grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpc_status_map.get(grpc_error.code()):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.EntityNotFound","title":"frequenz.client.base.exception.EntityNotFound","text":"<p>               Bases: <code>GrpcError</code></p> <p>The requested entity was not found.</p> <p>Note that this error differs from PermissionDenied. This error is used when the requested entity is not found, regardless of the user's permissions.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class EntityNotFound(GrpcError):\n    \"\"\"The requested entity was not found.\n\n    Note that this error differs from\n    [PermissionDenied][frequenz.client.base.exception.PermissionDenied]. This error is\n    used when the requested entity is not found, regardless of the user's permissions.\n    \"\"\"\n\n    def __init__(\n        self, *, server_url: str, operation: str, grpc_error: Exception\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error originating this exception.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"The requested entity was not found\",\n            grpc_error=grpc_error,\n            retryable=True,  # If the entity is added later it might succeed\n        )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.EntityNotFound-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.EntityNotFound.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.EntityNotFound.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error = grpc_error\n</code></pre> <p>The original gRPC error.</p> <p>This is either a <code>grpclib.GRPCError</code> or a <code>grpc.aio.AioRpcError</code> depending on which library is used. We can't type this correctly if we want this library to work when only one of the libraries is installed.</p> Tip <p>If you need to get this error for a particular library, use the appropriate property:</p> <ul> <li>grpclib_error   for <code>grpclib.GRPCError</code></li> <li>grpcio_error for   <code>grpc.aio.AioRpcError</code></li> </ul>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.EntityNotFound.grpcio_error","title":"grpcio_error  <code>property</code>","text":"<pre><code>grpcio_error: GrpcioError\n</code></pre> <p>The original <code>grpc.aio.AioRpcError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.EntityNotFound.grpclib_error","title":"grpclib_error  <code>property</code>","text":"<pre><code>grpclib_error: GrpclibError\n</code></pre> <p>The original <code>grpclib.GRPCError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.EntityNotFound.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.EntityNotFound.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.EntityNotFound.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.EntityNotFound-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.EntityNotFound.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>Exception</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self, *, server_url: str, operation: str, grpc_error: Exception\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error originating this exception.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"The requested entity was not found\",\n        grpc_error=grpc_error,\n        retryable=True,  # If the entity is added later it might succeed\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.EntityNotFound.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>Exception</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: Exception\n        ) -&gt; GrpcError: ...\n\n    if isinstance(grpc_error, _grpchacks.GrpclibError):\n        import grpclib  # pylint: disable=import-outside-toplevel\n\n        grpclib_status_map: dict[grpclib.Status, Ctor] = {\n            grpclib.Status.CANCELLED: OperationCancelled,\n            grpclib.Status.UNKNOWN: UnknownError,\n            grpclib.Status.INVALID_ARGUMENT: InvalidArgument,\n            grpclib.Status.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpclib.Status.NOT_FOUND: EntityNotFound,\n            grpclib.Status.ALREADY_EXISTS: EntityAlreadyExists,\n            grpclib.Status.PERMISSION_DENIED: PermissionDenied,\n            grpclib.Status.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpclib.Status.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpclib.Status.ABORTED: OperationAborted,\n            grpclib.Status.OUT_OF_RANGE: OperationOutOfRange,\n            grpclib.Status.UNIMPLEMENTED: OperationNotImplemented,\n            grpclib.Status.INTERNAL: InternalError,\n            grpclib.Status.UNAVAILABLE: ServiceUnavailable,\n            grpclib.Status.DATA_LOSS: DataLoss,\n            grpclib.Status.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpclib_status_map.get(grpc_error.status):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    elif isinstance(grpc_error, _grpchacks.GrpcioError):\n        import grpc  # pylint: disable=import-outside-toplevel\n\n        grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n            grpc.StatusCode.CANCELLED: OperationCancelled,\n            grpc.StatusCode.UNKNOWN: UnknownError,\n            grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n            grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpc.StatusCode.NOT_FOUND: EntityNotFound,\n            grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n            grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n            grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpc.StatusCode.ABORTED: OperationAborted,\n            grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n            grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n            grpc.StatusCode.INTERNAL: InternalError,\n            grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n            grpc.StatusCode.DATA_LOSS: DataLoss,\n            grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpc_status_map.get(grpc_error.code()):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.GrpcError","title":"frequenz.client.base.exception.GrpcError","text":"<p>               Bases: <code>ApiClientError</code></p> <p>The gRPC server returned an error with a status code.</p> <p>These errors are specific to gRPC. If you want to use the client in a protocol-independent way, you should avoid catching this exception. Catching subclasses that don't have grpc in their name should be protocol-independent.</p> <p>The following sub-classes are available:</p> <ul> <li>DataLoss: Unrecoverable data loss or   corruption.</li> <li>EntityAlreadyExists: The   entity that we attempted to create already exists.</li> <li>EntityNotFound: The requested   entity was not found.</li> <li>InternalError: Some invariants   expected by the underlying system have been broken.</li> <li>InvalidArgument: The client   specified an invalid argument.</li> <li>OperationAborted: The   operation was aborted.</li> <li>OperationCancelled: The   operation was cancelled.</li> <li>OperationNotImplemented:   The operation is not implemented or not supported/enabled in this service.</li> <li>OperationOutOfRange: The   operation was attempted past the valid range.</li> <li>OperationPreconditionFailed:   The operation was rejected because the system is not in a required state.</li> <li>OperationTimedOut: The time   limit was exceeded while waiting for the operation to complete.</li> <li>OperationUnauthenticated:   The request does not have valid authentication credentials for the operation.</li> <li>PermissionDenied: The caller   does not have permission to execute the specified operation.</li> <li>ResourceExhausted: Some   resource has been exhausted (for example per-user quota, disk space, etc.).</li> <li>ServiceUnavailable: The   service is currently unavailable.</li> <li>UnknownError: There was an error   that can't be described using other statuses.</li> <li>UnrecognizedGrpcStatus:   The gRPC server returned an unrecognized status code.</li> </ul> References <ul> <li>gRPC status    codes</li> </ul> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class GrpcError(ApiClientError):\n    \"\"\"The gRPC server returned an error with a status code.\n\n    These errors are specific to gRPC. If you want to use the client in\n    a protocol-independent way, you should avoid catching this exception. Catching\n    subclasses that don't have *grpc* in their name should be protocol-independent.\n\n    The following sub-classes are available:\n\n    - [DataLoss][frequenz.client.base.exception.DataLoss]: Unrecoverable data loss or\n      corruption.\n    - [EntityAlreadyExists][frequenz.client.base.exception.EntityAlreadyExists]: The\n      entity that we attempted to create already exists.\n    - [EntityNotFound][frequenz.client.base.exception.EntityNotFound]: The requested\n      entity was not found.\n    - [InternalError][frequenz.client.base.exception.InternalError]: Some invariants\n      expected by the underlying system have been broken.\n    - [InvalidArgument][frequenz.client.base.exception.InvalidArgument]: The client\n      specified an invalid argument.\n    - [OperationAborted][frequenz.client.base.exception.OperationAborted]: The\n      operation was aborted.\n    - [OperationCancelled][frequenz.client.base.exception.OperationCancelled]: The\n      operation was cancelled.\n    - [OperationNotImplemented][frequenz.client.base.exception.OperationNotImplemented]:\n      The operation is not implemented or not supported/enabled in this service.\n    - [OperationOutOfRange][frequenz.client.base.exception.OperationOutOfRange]: The\n      operation was attempted past the valid range.\n    - [OperationPreconditionFailed][frequenz.client.base.exception.OperationPreconditionFailed]:\n      The operation was rejected because the system is not in a required state.\n    - [OperationTimedOut][frequenz.client.base.exception.OperationTimedOut]: The time\n      limit was exceeded while waiting for the operation to complete.\n    - [OperationUnauthenticated][frequenz.client.base.exception.OperationUnauthenticated]:\n      The request does not have valid authentication credentials for the operation.\n    - [PermissionDenied][frequenz.client.base.exception.PermissionDenied]: The caller\n      does not have permission to execute the specified operation.\n    - [ResourceExhausted][frequenz.client.base.exception.ResourceExhausted]: Some\n      resource has been exhausted (for example per-user quota, disk space, etc.).\n    - [ServiceUnavailable][frequenz.client.base.exception.ServiceUnavailable]: The\n      service is currently unavailable.\n    - [UnknownError][frequenz.client.base.exception.UnknownError]: There was an error\n      that can't be described using other statuses.\n    - [UnrecognizedGrpcStatus][frequenz.client.base.exception.UnrecognizedGrpcStatus]:\n      The gRPC server returned an unrecognized status code.\n\n    References:\n        * [gRPC status\n           codes](https://github.com/grpc/grpc/blob/master/doc/statuscodes.md)\n    \"\"\"\n\n    def __init__(  # pylint: disable=too-many-arguments\n        self,\n        *,\n        server_url: str,\n        operation: str,\n        description: str,\n        grpc_error: Exception,\n        retryable: bool,\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            description: A human-readable description of the error.\n            grpc_error: The gRPC error originating this exception. This should be either\n                a `grpclib.GRPCError` or a `grpc.aio.AioRpcError` depending on which\n                library is used.\n            retryable: Whether retrying the operation might succeed.\n        \"\"\"\n        if isinstance(grpc_error, _grpchacks.GrpcioError):\n            status_name = grpc_error.code().name\n            message = grpc_error.details()\n            details = grpc_error.debug_error_string()\n        elif isinstance(grpc_error, _grpchacks.GrpclibError):\n            status_name = grpc_error.status.name\n            message = grpc_error.message\n            details = grpc_error.details\n        else:\n            assert False, (\n                \"GrpcError should only be instantiated with a gRPC error: \"\n                \"grpclib.GRPCError or grpc.aio.AioRpcError\"\n            )\n        message = f\": {message}\" if message else \"\"\n        details = f\" ({details})\" if details else \"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=f\"{description} &lt;status={status_name}&gt;{message}{details}\",\n            retryable=retryable,\n        )\n        self.description = description\n        \"\"\"The human-readable description of the error.\"\"\"\n\n        self.grpc_error = grpc_error\n        \"\"\"The original gRPC error.\n\n        This is either a `grpclib.GRPCError` or a `grpc.aio.AioRpcError` depending on\n        which library is used. We can't type this correctly if we want this library to\n        work when only one of the libraries is installed.\n\n        Tip:\n            If you need to get this error for a particular library, use the appropriate\n            property:\n\n            - [grpclib_error][frequenz.client.base.exception.GrpcError.grpclib_error]\n              for `grpclib.GRPCError`\n            - [grpcio_error][frequenz.client.base.exception.GrpcError.grpcio_error] for\n              `grpc.aio.AioRpcError`\n        \"\"\"\n\n    @property\n    def grpclib_error(self) -&gt; _grpchacks.GrpclibError:\n        \"\"\"The original `grpclib.GRPCError`.\"\"\"\n        assert isinstance(\n            self.grpc_error, _grpchacks.GrpclibError\n        ), \"This property is only available when using the grpclib library\"\n        return self.grpc_error\n\n    @property\n    def grpcio_error(self) -&gt; _grpchacks.GrpcioError:\n        \"\"\"The original `grpc.aio.AioRpcError`.\"\"\"\n        assert isinstance(\n            self.grpc_error, _grpchacks.GrpcioError\n        ), \"This property is only available when using the grpcio library\"\n        return self.grpc_error\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.GrpcError-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.GrpcError.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.GrpcError.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error = grpc_error\n</code></pre> <p>The original gRPC error.</p> <p>This is either a <code>grpclib.GRPCError</code> or a <code>grpc.aio.AioRpcError</code> depending on which library is used. We can't type this correctly if we want this library to work when only one of the libraries is installed.</p> Tip <p>If you need to get this error for a particular library, use the appropriate property:</p> <ul> <li>grpclib_error   for <code>grpclib.GRPCError</code></li> <li>grpcio_error for   <code>grpc.aio.AioRpcError</code></li> </ul>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.GrpcError.grpcio_error","title":"grpcio_error  <code>property</code>","text":"<pre><code>grpcio_error: GrpcioError\n</code></pre> <p>The original <code>grpc.aio.AioRpcError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.GrpcError.grpclib_error","title":"grpclib_error  <code>property</code>","text":"<pre><code>grpclib_error: GrpclibError\n</code></pre> <p>The original <code>grpclib.GRPCError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.GrpcError.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.GrpcError.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.GrpcError.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.GrpcError-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.GrpcError.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    description: str,\n    grpc_error: Exception,\n    retryable: bool\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>description</code> <p>A human-readable description of the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception. This should be either a <code>grpclib.GRPCError</code> or a <code>grpc.aio.AioRpcError</code> depending on which library is used.</p> <p> TYPE: <code>Exception</code> </p> <code>retryable</code> <p>Whether retrying the operation might succeed.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(  # pylint: disable=too-many-arguments\n    self,\n    *,\n    server_url: str,\n    operation: str,\n    description: str,\n    grpc_error: Exception,\n    retryable: bool,\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        description: A human-readable description of the error.\n        grpc_error: The gRPC error originating this exception. This should be either\n            a `grpclib.GRPCError` or a `grpc.aio.AioRpcError` depending on which\n            library is used.\n        retryable: Whether retrying the operation might succeed.\n    \"\"\"\n    if isinstance(grpc_error, _grpchacks.GrpcioError):\n        status_name = grpc_error.code().name\n        message = grpc_error.details()\n        details = grpc_error.debug_error_string()\n    elif isinstance(grpc_error, _grpchacks.GrpclibError):\n        status_name = grpc_error.status.name\n        message = grpc_error.message\n        details = grpc_error.details\n    else:\n        assert False, (\n            \"GrpcError should only be instantiated with a gRPC error: \"\n            \"grpclib.GRPCError or grpc.aio.AioRpcError\"\n        )\n    message = f\": {message}\" if message else \"\"\n    details = f\" ({details})\" if details else \"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=f\"{description} &lt;status={status_name}&gt;{message}{details}\",\n        retryable=retryable,\n    )\n    self.description = description\n    \"\"\"The human-readable description of the error.\"\"\"\n\n    self.grpc_error = grpc_error\n    \"\"\"The original gRPC error.\n\n    This is either a `grpclib.GRPCError` or a `grpc.aio.AioRpcError` depending on\n    which library is used. We can't type this correctly if we want this library to\n    work when only one of the libraries is installed.\n\n    Tip:\n        If you need to get this error for a particular library, use the appropriate\n        property:\n\n        - [grpclib_error][frequenz.client.base.exception.GrpcError.grpclib_error]\n          for `grpclib.GRPCError`\n        - [grpcio_error][frequenz.client.base.exception.GrpcError.grpcio_error] for\n          `grpc.aio.AioRpcError`\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.GrpcError.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>Exception</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: Exception\n        ) -&gt; GrpcError: ...\n\n    if isinstance(grpc_error, _grpchacks.GrpclibError):\n        import grpclib  # pylint: disable=import-outside-toplevel\n\n        grpclib_status_map: dict[grpclib.Status, Ctor] = {\n            grpclib.Status.CANCELLED: OperationCancelled,\n            grpclib.Status.UNKNOWN: UnknownError,\n            grpclib.Status.INVALID_ARGUMENT: InvalidArgument,\n            grpclib.Status.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpclib.Status.NOT_FOUND: EntityNotFound,\n            grpclib.Status.ALREADY_EXISTS: EntityAlreadyExists,\n            grpclib.Status.PERMISSION_DENIED: PermissionDenied,\n            grpclib.Status.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpclib.Status.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpclib.Status.ABORTED: OperationAborted,\n            grpclib.Status.OUT_OF_RANGE: OperationOutOfRange,\n            grpclib.Status.UNIMPLEMENTED: OperationNotImplemented,\n            grpclib.Status.INTERNAL: InternalError,\n            grpclib.Status.UNAVAILABLE: ServiceUnavailable,\n            grpclib.Status.DATA_LOSS: DataLoss,\n            grpclib.Status.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpclib_status_map.get(grpc_error.status):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    elif isinstance(grpc_error, _grpchacks.GrpcioError):\n        import grpc  # pylint: disable=import-outside-toplevel\n\n        grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n            grpc.StatusCode.CANCELLED: OperationCancelled,\n            grpc.StatusCode.UNKNOWN: UnknownError,\n            grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n            grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpc.StatusCode.NOT_FOUND: EntityNotFound,\n            grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n            grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n            grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpc.StatusCode.ABORTED: OperationAborted,\n            grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n            grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n            grpc.StatusCode.INTERNAL: InternalError,\n            grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n            grpc.StatusCode.DATA_LOSS: DataLoss,\n            grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpc_status_map.get(grpc_error.code()):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.InternalError","title":"frequenz.client.base.exception.InternalError","text":"<p>               Bases: <code>GrpcError</code></p> <p>Some invariants expected by the underlying system have been broken.</p> <p>This error code is reserved for serious errors.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class InternalError(GrpcError):\n    \"\"\"Some invariants expected by the underlying system have been broken.\n\n    This error code is reserved for serious errors.\n    \"\"\"\n\n    def __init__(\n        self, *, server_url: str, operation: str, grpc_error: Exception\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error originating this exception.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"Some invariants expected by the underlying system have been \"\n            \"broken\",\n            grpc_error=grpc_error,\n            retryable=True,  # If the system state changes it might succeed\n        )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.InternalError-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.InternalError.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.InternalError.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error = grpc_error\n</code></pre> <p>The original gRPC error.</p> <p>This is either a <code>grpclib.GRPCError</code> or a <code>grpc.aio.AioRpcError</code> depending on which library is used. We can't type this correctly if we want this library to work when only one of the libraries is installed.</p> Tip <p>If you need to get this error for a particular library, use the appropriate property:</p> <ul> <li>grpclib_error   for <code>grpclib.GRPCError</code></li> <li>grpcio_error for   <code>grpc.aio.AioRpcError</code></li> </ul>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.InternalError.grpcio_error","title":"grpcio_error  <code>property</code>","text":"<pre><code>grpcio_error: GrpcioError\n</code></pre> <p>The original <code>grpc.aio.AioRpcError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.InternalError.grpclib_error","title":"grpclib_error  <code>property</code>","text":"<pre><code>grpclib_error: GrpclibError\n</code></pre> <p>The original <code>grpclib.GRPCError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.InternalError.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.InternalError.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.InternalError.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.InternalError-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.InternalError.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>Exception</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self, *, server_url: str, operation: str, grpc_error: Exception\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error originating this exception.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"Some invariants expected by the underlying system have been \"\n        \"broken\",\n        grpc_error=grpc_error,\n        retryable=True,  # If the system state changes it might succeed\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.InternalError.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>Exception</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: Exception\n        ) -&gt; GrpcError: ...\n\n    if isinstance(grpc_error, _grpchacks.GrpclibError):\n        import grpclib  # pylint: disable=import-outside-toplevel\n\n        grpclib_status_map: dict[grpclib.Status, Ctor] = {\n            grpclib.Status.CANCELLED: OperationCancelled,\n            grpclib.Status.UNKNOWN: UnknownError,\n            grpclib.Status.INVALID_ARGUMENT: InvalidArgument,\n            grpclib.Status.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpclib.Status.NOT_FOUND: EntityNotFound,\n            grpclib.Status.ALREADY_EXISTS: EntityAlreadyExists,\n            grpclib.Status.PERMISSION_DENIED: PermissionDenied,\n            grpclib.Status.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpclib.Status.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpclib.Status.ABORTED: OperationAborted,\n            grpclib.Status.OUT_OF_RANGE: OperationOutOfRange,\n            grpclib.Status.UNIMPLEMENTED: OperationNotImplemented,\n            grpclib.Status.INTERNAL: InternalError,\n            grpclib.Status.UNAVAILABLE: ServiceUnavailable,\n            grpclib.Status.DATA_LOSS: DataLoss,\n            grpclib.Status.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpclib_status_map.get(grpc_error.status):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    elif isinstance(grpc_error, _grpchacks.GrpcioError):\n        import grpc  # pylint: disable=import-outside-toplevel\n\n        grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n            grpc.StatusCode.CANCELLED: OperationCancelled,\n            grpc.StatusCode.UNKNOWN: UnknownError,\n            grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n            grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpc.StatusCode.NOT_FOUND: EntityNotFound,\n            grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n            grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n            grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpc.StatusCode.ABORTED: OperationAborted,\n            grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n            grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n            grpc.StatusCode.INTERNAL: InternalError,\n            grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n            grpc.StatusCode.DATA_LOSS: DataLoss,\n            grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpc_status_map.get(grpc_error.code()):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.InvalidArgument","title":"frequenz.client.base.exception.InvalidArgument","text":"<p>               Bases: <code>GrpcError</code>, <code>ValueError</code></p> <p>The client specified an invalid argument.</p> <p>Note that this error differs from OperationPreconditionFailed. This error indicates arguments that are problematic regardless of the state of the system (e.g., a malformed file name).</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class InvalidArgument(GrpcError, ValueError):\n    \"\"\"The client specified an invalid argument.\n\n    Note that this error differs from\n    [OperationPreconditionFailed][frequenz.client.base.exception.OperationPreconditionFailed].\n    This error indicates arguments that are problematic regardless of the state of the\n    system (e.g., a malformed file name).\n    \"\"\"\n\n    def __init__(\n        self, *, server_url: str, operation: str, grpc_error: Exception\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error originating this exception.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"The client specified an invalid argument\",\n            grpc_error=grpc_error,\n            retryable=False,\n        )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.InvalidArgument-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.InvalidArgument.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.InvalidArgument.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error = grpc_error\n</code></pre> <p>The original gRPC error.</p> <p>This is either a <code>grpclib.GRPCError</code> or a <code>grpc.aio.AioRpcError</code> depending on which library is used. We can't type this correctly if we want this library to work when only one of the libraries is installed.</p> Tip <p>If you need to get this error for a particular library, use the appropriate property:</p> <ul> <li>grpclib_error   for <code>grpclib.GRPCError</code></li> <li>grpcio_error for   <code>grpc.aio.AioRpcError</code></li> </ul>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.InvalidArgument.grpcio_error","title":"grpcio_error  <code>property</code>","text":"<pre><code>grpcio_error: GrpcioError\n</code></pre> <p>The original <code>grpc.aio.AioRpcError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.InvalidArgument.grpclib_error","title":"grpclib_error  <code>property</code>","text":"<pre><code>grpclib_error: GrpclibError\n</code></pre> <p>The original <code>grpclib.GRPCError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.InvalidArgument.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.InvalidArgument.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.InvalidArgument.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.InvalidArgument-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.InvalidArgument.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>Exception</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self, *, server_url: str, operation: str, grpc_error: Exception\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error originating this exception.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"The client specified an invalid argument\",\n        grpc_error=grpc_error,\n        retryable=False,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.InvalidArgument.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>Exception</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: Exception\n        ) -&gt; GrpcError: ...\n\n    if isinstance(grpc_error, _grpchacks.GrpclibError):\n        import grpclib  # pylint: disable=import-outside-toplevel\n\n        grpclib_status_map: dict[grpclib.Status, Ctor] = {\n            grpclib.Status.CANCELLED: OperationCancelled,\n            grpclib.Status.UNKNOWN: UnknownError,\n            grpclib.Status.INVALID_ARGUMENT: InvalidArgument,\n            grpclib.Status.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpclib.Status.NOT_FOUND: EntityNotFound,\n            grpclib.Status.ALREADY_EXISTS: EntityAlreadyExists,\n            grpclib.Status.PERMISSION_DENIED: PermissionDenied,\n            grpclib.Status.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpclib.Status.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpclib.Status.ABORTED: OperationAborted,\n            grpclib.Status.OUT_OF_RANGE: OperationOutOfRange,\n            grpclib.Status.UNIMPLEMENTED: OperationNotImplemented,\n            grpclib.Status.INTERNAL: InternalError,\n            grpclib.Status.UNAVAILABLE: ServiceUnavailable,\n            grpclib.Status.DATA_LOSS: DataLoss,\n            grpclib.Status.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpclib_status_map.get(grpc_error.status):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    elif isinstance(grpc_error, _grpchacks.GrpcioError):\n        import grpc  # pylint: disable=import-outside-toplevel\n\n        grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n            grpc.StatusCode.CANCELLED: OperationCancelled,\n            grpc.StatusCode.UNKNOWN: UnknownError,\n            grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n            grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpc.StatusCode.NOT_FOUND: EntityNotFound,\n            grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n            grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n            grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpc.StatusCode.ABORTED: OperationAborted,\n            grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n            grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n            grpc.StatusCode.INTERNAL: InternalError,\n            grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n            grpc.StatusCode.DATA_LOSS: DataLoss,\n            grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpc_status_map.get(grpc_error.code()):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationAborted","title":"frequenz.client.base.exception.OperationAborted","text":"<p>               Bases: <code>GrpcError</code></p> <p>The operation was aborted.</p> <p>Typically due to a concurrency issue or transaction abort.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class OperationAborted(GrpcError):\n    \"\"\"The operation was aborted.\n\n    Typically due to a concurrency issue or transaction abort.\n    \"\"\"\n\n    def __init__(\n        self, *, server_url: str, operation: str, grpc_error: Exception\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error originating this exception.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"The operation was aborted\",\n            grpc_error=grpc_error,\n            retryable=True,\n        )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationAborted-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationAborted.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationAborted.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error = grpc_error\n</code></pre> <p>The original gRPC error.</p> <p>This is either a <code>grpclib.GRPCError</code> or a <code>grpc.aio.AioRpcError</code> depending on which library is used. We can't type this correctly if we want this library to work when only one of the libraries is installed.</p> Tip <p>If you need to get this error for a particular library, use the appropriate property:</p> <ul> <li>grpclib_error   for <code>grpclib.GRPCError</code></li> <li>grpcio_error for   <code>grpc.aio.AioRpcError</code></li> </ul>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationAborted.grpcio_error","title":"grpcio_error  <code>property</code>","text":"<pre><code>grpcio_error: GrpcioError\n</code></pre> <p>The original <code>grpc.aio.AioRpcError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationAborted.grpclib_error","title":"grpclib_error  <code>property</code>","text":"<pre><code>grpclib_error: GrpclibError\n</code></pre> <p>The original <code>grpclib.GRPCError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationAborted.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationAborted.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationAborted.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationAborted-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationAborted.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>Exception</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self, *, server_url: str, operation: str, grpc_error: Exception\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error originating this exception.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"The operation was aborted\",\n        grpc_error=grpc_error,\n        retryable=True,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationAborted.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>Exception</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: Exception\n        ) -&gt; GrpcError: ...\n\n    if isinstance(grpc_error, _grpchacks.GrpclibError):\n        import grpclib  # pylint: disable=import-outside-toplevel\n\n        grpclib_status_map: dict[grpclib.Status, Ctor] = {\n            grpclib.Status.CANCELLED: OperationCancelled,\n            grpclib.Status.UNKNOWN: UnknownError,\n            grpclib.Status.INVALID_ARGUMENT: InvalidArgument,\n            grpclib.Status.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpclib.Status.NOT_FOUND: EntityNotFound,\n            grpclib.Status.ALREADY_EXISTS: EntityAlreadyExists,\n            grpclib.Status.PERMISSION_DENIED: PermissionDenied,\n            grpclib.Status.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpclib.Status.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpclib.Status.ABORTED: OperationAborted,\n            grpclib.Status.OUT_OF_RANGE: OperationOutOfRange,\n            grpclib.Status.UNIMPLEMENTED: OperationNotImplemented,\n            grpclib.Status.INTERNAL: InternalError,\n            grpclib.Status.UNAVAILABLE: ServiceUnavailable,\n            grpclib.Status.DATA_LOSS: DataLoss,\n            grpclib.Status.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpclib_status_map.get(grpc_error.status):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    elif isinstance(grpc_error, _grpchacks.GrpcioError):\n        import grpc  # pylint: disable=import-outside-toplevel\n\n        grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n            grpc.StatusCode.CANCELLED: OperationCancelled,\n            grpc.StatusCode.UNKNOWN: UnknownError,\n            grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n            grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpc.StatusCode.NOT_FOUND: EntityNotFound,\n            grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n            grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n            grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpc.StatusCode.ABORTED: OperationAborted,\n            grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n            grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n            grpc.StatusCode.INTERNAL: InternalError,\n            grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n            grpc.StatusCode.DATA_LOSS: DataLoss,\n            grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpc_status_map.get(grpc_error.code()):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationCancelled","title":"frequenz.client.base.exception.OperationCancelled","text":"<p>               Bases: <code>GrpcError</code></p> <p>The operation was cancelled.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class OperationCancelled(GrpcError):\n    \"\"\"The operation was cancelled.\"\"\"\n\n    def __init__(\n        self, *, server_url: str, operation: str, grpc_error: Exception\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error originating this exception.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"The operation was cancelled\",\n            grpc_error=grpc_error,\n            retryable=True,\n        )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationCancelled-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationCancelled.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationCancelled.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error = grpc_error\n</code></pre> <p>The original gRPC error.</p> <p>This is either a <code>grpclib.GRPCError</code> or a <code>grpc.aio.AioRpcError</code> depending on which library is used. We can't type this correctly if we want this library to work when only one of the libraries is installed.</p> Tip <p>If you need to get this error for a particular library, use the appropriate property:</p> <ul> <li>grpclib_error   for <code>grpclib.GRPCError</code></li> <li>grpcio_error for   <code>grpc.aio.AioRpcError</code></li> </ul>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationCancelled.grpcio_error","title":"grpcio_error  <code>property</code>","text":"<pre><code>grpcio_error: GrpcioError\n</code></pre> <p>The original <code>grpc.aio.AioRpcError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationCancelled.grpclib_error","title":"grpclib_error  <code>property</code>","text":"<pre><code>grpclib_error: GrpclibError\n</code></pre> <p>The original <code>grpclib.GRPCError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationCancelled.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationCancelled.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationCancelled.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationCancelled-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationCancelled.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>Exception</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self, *, server_url: str, operation: str, grpc_error: Exception\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error originating this exception.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"The operation was cancelled\",\n        grpc_error=grpc_error,\n        retryable=True,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationCancelled.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>Exception</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: Exception\n        ) -&gt; GrpcError: ...\n\n    if isinstance(grpc_error, _grpchacks.GrpclibError):\n        import grpclib  # pylint: disable=import-outside-toplevel\n\n        grpclib_status_map: dict[grpclib.Status, Ctor] = {\n            grpclib.Status.CANCELLED: OperationCancelled,\n            grpclib.Status.UNKNOWN: UnknownError,\n            grpclib.Status.INVALID_ARGUMENT: InvalidArgument,\n            grpclib.Status.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpclib.Status.NOT_FOUND: EntityNotFound,\n            grpclib.Status.ALREADY_EXISTS: EntityAlreadyExists,\n            grpclib.Status.PERMISSION_DENIED: PermissionDenied,\n            grpclib.Status.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpclib.Status.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpclib.Status.ABORTED: OperationAborted,\n            grpclib.Status.OUT_OF_RANGE: OperationOutOfRange,\n            grpclib.Status.UNIMPLEMENTED: OperationNotImplemented,\n            grpclib.Status.INTERNAL: InternalError,\n            grpclib.Status.UNAVAILABLE: ServiceUnavailable,\n            grpclib.Status.DATA_LOSS: DataLoss,\n            grpclib.Status.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpclib_status_map.get(grpc_error.status):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    elif isinstance(grpc_error, _grpchacks.GrpcioError):\n        import grpc  # pylint: disable=import-outside-toplevel\n\n        grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n            grpc.StatusCode.CANCELLED: OperationCancelled,\n            grpc.StatusCode.UNKNOWN: UnknownError,\n            grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n            grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpc.StatusCode.NOT_FOUND: EntityNotFound,\n            grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n            grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n            grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpc.StatusCode.ABORTED: OperationAborted,\n            grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n            grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n            grpc.StatusCode.INTERNAL: InternalError,\n            grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n            grpc.StatusCode.DATA_LOSS: DataLoss,\n            grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpc_status_map.get(grpc_error.code()):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationNotImplemented","title":"frequenz.client.base.exception.OperationNotImplemented","text":"<p>               Bases: <code>GrpcError</code></p> <p>The operation is not implemented or not supported/enabled in this service.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class OperationNotImplemented(GrpcError):\n    \"\"\"The operation is not implemented or not supported/enabled in this service.\"\"\"\n\n    def __init__(\n        self, *, server_url: str, operation: str, grpc_error: Exception\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error originating this exception.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"The operation is not implemented or not supported/enabled in \"\n            \"this service\",\n            grpc_error=grpc_error,\n            retryable=False,\n        )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationNotImplemented-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationNotImplemented.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationNotImplemented.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error = grpc_error\n</code></pre> <p>The original gRPC error.</p> <p>This is either a <code>grpclib.GRPCError</code> or a <code>grpc.aio.AioRpcError</code> depending on which library is used. We can't type this correctly if we want this library to work when only one of the libraries is installed.</p> Tip <p>If you need to get this error for a particular library, use the appropriate property:</p> <ul> <li>grpclib_error   for <code>grpclib.GRPCError</code></li> <li>grpcio_error for   <code>grpc.aio.AioRpcError</code></li> </ul>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationNotImplemented.grpcio_error","title":"grpcio_error  <code>property</code>","text":"<pre><code>grpcio_error: GrpcioError\n</code></pre> <p>The original <code>grpc.aio.AioRpcError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationNotImplemented.grpclib_error","title":"grpclib_error  <code>property</code>","text":"<pre><code>grpclib_error: GrpclibError\n</code></pre> <p>The original <code>grpclib.GRPCError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationNotImplemented.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationNotImplemented.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationNotImplemented.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationNotImplemented-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationNotImplemented.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>Exception</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self, *, server_url: str, operation: str, grpc_error: Exception\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error originating this exception.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"The operation is not implemented or not supported/enabled in \"\n        \"this service\",\n        grpc_error=grpc_error,\n        retryable=False,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationNotImplemented.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>Exception</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: Exception\n        ) -&gt; GrpcError: ...\n\n    if isinstance(grpc_error, _grpchacks.GrpclibError):\n        import grpclib  # pylint: disable=import-outside-toplevel\n\n        grpclib_status_map: dict[grpclib.Status, Ctor] = {\n            grpclib.Status.CANCELLED: OperationCancelled,\n            grpclib.Status.UNKNOWN: UnknownError,\n            grpclib.Status.INVALID_ARGUMENT: InvalidArgument,\n            grpclib.Status.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpclib.Status.NOT_FOUND: EntityNotFound,\n            grpclib.Status.ALREADY_EXISTS: EntityAlreadyExists,\n            grpclib.Status.PERMISSION_DENIED: PermissionDenied,\n            grpclib.Status.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpclib.Status.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpclib.Status.ABORTED: OperationAborted,\n            grpclib.Status.OUT_OF_RANGE: OperationOutOfRange,\n            grpclib.Status.UNIMPLEMENTED: OperationNotImplemented,\n            grpclib.Status.INTERNAL: InternalError,\n            grpclib.Status.UNAVAILABLE: ServiceUnavailable,\n            grpclib.Status.DATA_LOSS: DataLoss,\n            grpclib.Status.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpclib_status_map.get(grpc_error.status):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    elif isinstance(grpc_error, _grpchacks.GrpcioError):\n        import grpc  # pylint: disable=import-outside-toplevel\n\n        grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n            grpc.StatusCode.CANCELLED: OperationCancelled,\n            grpc.StatusCode.UNKNOWN: UnknownError,\n            grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n            grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpc.StatusCode.NOT_FOUND: EntityNotFound,\n            grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n            grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n            grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpc.StatusCode.ABORTED: OperationAborted,\n            grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n            grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n            grpc.StatusCode.INTERNAL: InternalError,\n            grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n            grpc.StatusCode.DATA_LOSS: DataLoss,\n            grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpc_status_map.get(grpc_error.code()):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationOutOfRange","title":"frequenz.client.base.exception.OperationOutOfRange","text":"<p>               Bases: <code>GrpcError</code></p> <p>The operation was attempted past the valid range.</p> <p>Unlike InvalidArgument, this error indicates a problem that may be fixed if the system state changes.</p> <p>There is a fair bit of overlap with OperationPreconditionFailed, this error is just a more specific version of that error and could be the result of an operation that doesn't even take any arguments.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class OperationOutOfRange(GrpcError):\n    \"\"\"The operation was attempted past the valid range.\n\n    Unlike [InvalidArgument][frequenz.client.base.exception.InvalidArgument], this error\n    indicates a problem that may be fixed if the system state changes.\n\n    There is a fair bit of overlap with\n    [OperationPreconditionFailed][frequenz.client.base.exception.OperationPreconditionFailed],\n    this error is just a more specific version of that error and could be the result of\n    an operation that doesn't even take any arguments.\n    \"\"\"\n\n    def __init__(\n        self, *, server_url: str, operation: str, grpc_error: Exception\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error originating this exception.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"The operation was attempted past the valid range\",\n            grpc_error=grpc_error,\n            retryable=True,  # If the system state changes it might succeed\n        )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationOutOfRange-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationOutOfRange.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationOutOfRange.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error = grpc_error\n</code></pre> <p>The original gRPC error.</p> <p>This is either a <code>grpclib.GRPCError</code> or a <code>grpc.aio.AioRpcError</code> depending on which library is used. We can't type this correctly if we want this library to work when only one of the libraries is installed.</p> Tip <p>If you need to get this error for a particular library, use the appropriate property:</p> <ul> <li>grpclib_error   for <code>grpclib.GRPCError</code></li> <li>grpcio_error for   <code>grpc.aio.AioRpcError</code></li> </ul>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationOutOfRange.grpcio_error","title":"grpcio_error  <code>property</code>","text":"<pre><code>grpcio_error: GrpcioError\n</code></pre> <p>The original <code>grpc.aio.AioRpcError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationOutOfRange.grpclib_error","title":"grpclib_error  <code>property</code>","text":"<pre><code>grpclib_error: GrpclibError\n</code></pre> <p>The original <code>grpclib.GRPCError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationOutOfRange.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationOutOfRange.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationOutOfRange.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationOutOfRange-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationOutOfRange.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>Exception</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self, *, server_url: str, operation: str, grpc_error: Exception\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error originating this exception.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"The operation was attempted past the valid range\",\n        grpc_error=grpc_error,\n        retryable=True,  # If the system state changes it might succeed\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationOutOfRange.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>Exception</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: Exception\n        ) -&gt; GrpcError: ...\n\n    if isinstance(grpc_error, _grpchacks.GrpclibError):\n        import grpclib  # pylint: disable=import-outside-toplevel\n\n        grpclib_status_map: dict[grpclib.Status, Ctor] = {\n            grpclib.Status.CANCELLED: OperationCancelled,\n            grpclib.Status.UNKNOWN: UnknownError,\n            grpclib.Status.INVALID_ARGUMENT: InvalidArgument,\n            grpclib.Status.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpclib.Status.NOT_FOUND: EntityNotFound,\n            grpclib.Status.ALREADY_EXISTS: EntityAlreadyExists,\n            grpclib.Status.PERMISSION_DENIED: PermissionDenied,\n            grpclib.Status.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpclib.Status.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpclib.Status.ABORTED: OperationAborted,\n            grpclib.Status.OUT_OF_RANGE: OperationOutOfRange,\n            grpclib.Status.UNIMPLEMENTED: OperationNotImplemented,\n            grpclib.Status.INTERNAL: InternalError,\n            grpclib.Status.UNAVAILABLE: ServiceUnavailable,\n            grpclib.Status.DATA_LOSS: DataLoss,\n            grpclib.Status.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpclib_status_map.get(grpc_error.status):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    elif isinstance(grpc_error, _grpchacks.GrpcioError):\n        import grpc  # pylint: disable=import-outside-toplevel\n\n        grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n            grpc.StatusCode.CANCELLED: OperationCancelled,\n            grpc.StatusCode.UNKNOWN: UnknownError,\n            grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n            grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpc.StatusCode.NOT_FOUND: EntityNotFound,\n            grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n            grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n            grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpc.StatusCode.ABORTED: OperationAborted,\n            grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n            grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n            grpc.StatusCode.INTERNAL: InternalError,\n            grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n            grpc.StatusCode.DATA_LOSS: DataLoss,\n            grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpc_status_map.get(grpc_error.code()):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationPreconditionFailed","title":"frequenz.client.base.exception.OperationPreconditionFailed","text":"<p>               Bases: <code>GrpcError</code></p> <p>The operation was rejected because the system is not in a required state.</p> <p>For example, the directory to be deleted is non-empty, an rmdir operation is applied to a non-directory, etc. The user should perform some corrective action before retrying the operation.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class OperationPreconditionFailed(GrpcError):\n    \"\"\"The operation was rejected because the system is not in a required state.\n\n    For example, the directory to be deleted is non-empty, an rmdir operation is applied\n    to a non-directory, etc. The user should perform some corrective action before\n    retrying the operation.\n    \"\"\"\n\n    def __init__(\n        self, *, server_url: str, operation: str, grpc_error: Exception\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error originating this exception.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"The operation was rejected because the system is not in a \"\n            \"required state\",\n            grpc_error=grpc_error,\n            retryable=True,  # If the system state changes it might succeed\n        )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationPreconditionFailed-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationPreconditionFailed.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationPreconditionFailed.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error = grpc_error\n</code></pre> <p>The original gRPC error.</p> <p>This is either a <code>grpclib.GRPCError</code> or a <code>grpc.aio.AioRpcError</code> depending on which library is used. We can't type this correctly if we want this library to work when only one of the libraries is installed.</p> Tip <p>If you need to get this error for a particular library, use the appropriate property:</p> <ul> <li>grpclib_error   for <code>grpclib.GRPCError</code></li> <li>grpcio_error for   <code>grpc.aio.AioRpcError</code></li> </ul>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationPreconditionFailed.grpcio_error","title":"grpcio_error  <code>property</code>","text":"<pre><code>grpcio_error: GrpcioError\n</code></pre> <p>The original <code>grpc.aio.AioRpcError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationPreconditionFailed.grpclib_error","title":"grpclib_error  <code>property</code>","text":"<pre><code>grpclib_error: GrpclibError\n</code></pre> <p>The original <code>grpclib.GRPCError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationPreconditionFailed.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationPreconditionFailed.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationPreconditionFailed.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationPreconditionFailed-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationPreconditionFailed.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>Exception</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self, *, server_url: str, operation: str, grpc_error: Exception\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error originating this exception.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"The operation was rejected because the system is not in a \"\n        \"required state\",\n        grpc_error=grpc_error,\n        retryable=True,  # If the system state changes it might succeed\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationPreconditionFailed.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>Exception</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: Exception\n        ) -&gt; GrpcError: ...\n\n    if isinstance(grpc_error, _grpchacks.GrpclibError):\n        import grpclib  # pylint: disable=import-outside-toplevel\n\n        grpclib_status_map: dict[grpclib.Status, Ctor] = {\n            grpclib.Status.CANCELLED: OperationCancelled,\n            grpclib.Status.UNKNOWN: UnknownError,\n            grpclib.Status.INVALID_ARGUMENT: InvalidArgument,\n            grpclib.Status.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpclib.Status.NOT_FOUND: EntityNotFound,\n            grpclib.Status.ALREADY_EXISTS: EntityAlreadyExists,\n            grpclib.Status.PERMISSION_DENIED: PermissionDenied,\n            grpclib.Status.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpclib.Status.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpclib.Status.ABORTED: OperationAborted,\n            grpclib.Status.OUT_OF_RANGE: OperationOutOfRange,\n            grpclib.Status.UNIMPLEMENTED: OperationNotImplemented,\n            grpclib.Status.INTERNAL: InternalError,\n            grpclib.Status.UNAVAILABLE: ServiceUnavailable,\n            grpclib.Status.DATA_LOSS: DataLoss,\n            grpclib.Status.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpclib_status_map.get(grpc_error.status):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    elif isinstance(grpc_error, _grpchacks.GrpcioError):\n        import grpc  # pylint: disable=import-outside-toplevel\n\n        grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n            grpc.StatusCode.CANCELLED: OperationCancelled,\n            grpc.StatusCode.UNKNOWN: UnknownError,\n            grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n            grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpc.StatusCode.NOT_FOUND: EntityNotFound,\n            grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n            grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n            grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpc.StatusCode.ABORTED: OperationAborted,\n            grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n            grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n            grpc.StatusCode.INTERNAL: InternalError,\n            grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n            grpc.StatusCode.DATA_LOSS: DataLoss,\n            grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpc_status_map.get(grpc_error.code()):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationTimedOut","title":"frequenz.client.base.exception.OperationTimedOut","text":"<p>               Bases: <code>GrpcError</code></p> <p>The time limit was exceeded while waiting for the operationt o complete.</p> <p>For operations that change the state of the system, this error may be returned even if the operation has completed successfully. For example, a successful response from a server could have been delayed long.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class OperationTimedOut(GrpcError):\n    \"\"\"The time limit was exceeded while waiting for the operationt o complete.\n\n    For operations that change the state of the system, this error may be returned even\n    if the operation has completed successfully. For example, a successful response from\n    a server could have been delayed long.\n    \"\"\"\n\n    def __init__(\n        self, *, server_url: str, operation: str, grpc_error: Exception\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error originating this exception.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"The time limit was exceeded while waiting for the operation \"\n            \"to complete\",\n            grpc_error=grpc_error,\n            retryable=True,\n        )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationTimedOut-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationTimedOut.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationTimedOut.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error = grpc_error\n</code></pre> <p>The original gRPC error.</p> <p>This is either a <code>grpclib.GRPCError</code> or a <code>grpc.aio.AioRpcError</code> depending on which library is used. We can't type this correctly if we want this library to work when only one of the libraries is installed.</p> Tip <p>If you need to get this error for a particular library, use the appropriate property:</p> <ul> <li>grpclib_error   for <code>grpclib.GRPCError</code></li> <li>grpcio_error for   <code>grpc.aio.AioRpcError</code></li> </ul>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationTimedOut.grpcio_error","title":"grpcio_error  <code>property</code>","text":"<pre><code>grpcio_error: GrpcioError\n</code></pre> <p>The original <code>grpc.aio.AioRpcError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationTimedOut.grpclib_error","title":"grpclib_error  <code>property</code>","text":"<pre><code>grpclib_error: GrpclibError\n</code></pre> <p>The original <code>grpclib.GRPCError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationTimedOut.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationTimedOut.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationTimedOut.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationTimedOut-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationTimedOut.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>Exception</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self, *, server_url: str, operation: str, grpc_error: Exception\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error originating this exception.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"The time limit was exceeded while waiting for the operation \"\n        \"to complete\",\n        grpc_error=grpc_error,\n        retryable=True,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationTimedOut.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>Exception</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: Exception\n        ) -&gt; GrpcError: ...\n\n    if isinstance(grpc_error, _grpchacks.GrpclibError):\n        import grpclib  # pylint: disable=import-outside-toplevel\n\n        grpclib_status_map: dict[grpclib.Status, Ctor] = {\n            grpclib.Status.CANCELLED: OperationCancelled,\n            grpclib.Status.UNKNOWN: UnknownError,\n            grpclib.Status.INVALID_ARGUMENT: InvalidArgument,\n            grpclib.Status.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpclib.Status.NOT_FOUND: EntityNotFound,\n            grpclib.Status.ALREADY_EXISTS: EntityAlreadyExists,\n            grpclib.Status.PERMISSION_DENIED: PermissionDenied,\n            grpclib.Status.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpclib.Status.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpclib.Status.ABORTED: OperationAborted,\n            grpclib.Status.OUT_OF_RANGE: OperationOutOfRange,\n            grpclib.Status.UNIMPLEMENTED: OperationNotImplemented,\n            grpclib.Status.INTERNAL: InternalError,\n            grpclib.Status.UNAVAILABLE: ServiceUnavailable,\n            grpclib.Status.DATA_LOSS: DataLoss,\n            grpclib.Status.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpclib_status_map.get(grpc_error.status):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    elif isinstance(grpc_error, _grpchacks.GrpcioError):\n        import grpc  # pylint: disable=import-outside-toplevel\n\n        grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n            grpc.StatusCode.CANCELLED: OperationCancelled,\n            grpc.StatusCode.UNKNOWN: UnknownError,\n            grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n            grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpc.StatusCode.NOT_FOUND: EntityNotFound,\n            grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n            grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n            grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpc.StatusCode.ABORTED: OperationAborted,\n            grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n            grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n            grpc.StatusCode.INTERNAL: InternalError,\n            grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n            grpc.StatusCode.DATA_LOSS: DataLoss,\n            grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpc_status_map.get(grpc_error.code()):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationUnauthenticated","title":"frequenz.client.base.exception.OperationUnauthenticated","text":"<p>               Bases: <code>GrpcError</code></p> <p>The request does not have valid authentication credentials for the operation.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class OperationUnauthenticated(GrpcError):\n    \"\"\"The request does not have valid authentication credentials for the operation.\"\"\"\n\n    def __init__(\n        self, *, server_url: str, operation: str, grpc_error: Exception\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error originating this exception.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"The request does not have valid authentication credentials \"\n            \"for the operation\",\n            grpc_error=grpc_error,\n            retryable=False,\n        )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationUnauthenticated-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationUnauthenticated.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationUnauthenticated.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error = grpc_error\n</code></pre> <p>The original gRPC error.</p> <p>This is either a <code>grpclib.GRPCError</code> or a <code>grpc.aio.AioRpcError</code> depending on which library is used. We can't type this correctly if we want this library to work when only one of the libraries is installed.</p> Tip <p>If you need to get this error for a particular library, use the appropriate property:</p> <ul> <li>grpclib_error   for <code>grpclib.GRPCError</code></li> <li>grpcio_error for   <code>grpc.aio.AioRpcError</code></li> </ul>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationUnauthenticated.grpcio_error","title":"grpcio_error  <code>property</code>","text":"<pre><code>grpcio_error: GrpcioError\n</code></pre> <p>The original <code>grpc.aio.AioRpcError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationUnauthenticated.grpclib_error","title":"grpclib_error  <code>property</code>","text":"<pre><code>grpclib_error: GrpclibError\n</code></pre> <p>The original <code>grpclib.GRPCError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationUnauthenticated.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationUnauthenticated.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationUnauthenticated.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationUnauthenticated-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationUnauthenticated.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>Exception</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self, *, server_url: str, operation: str, grpc_error: Exception\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error originating this exception.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"The request does not have valid authentication credentials \"\n        \"for the operation\",\n        grpc_error=grpc_error,\n        retryable=False,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.OperationUnauthenticated.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>Exception</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: Exception\n        ) -&gt; GrpcError: ...\n\n    if isinstance(grpc_error, _grpchacks.GrpclibError):\n        import grpclib  # pylint: disable=import-outside-toplevel\n\n        grpclib_status_map: dict[grpclib.Status, Ctor] = {\n            grpclib.Status.CANCELLED: OperationCancelled,\n            grpclib.Status.UNKNOWN: UnknownError,\n            grpclib.Status.INVALID_ARGUMENT: InvalidArgument,\n            grpclib.Status.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpclib.Status.NOT_FOUND: EntityNotFound,\n            grpclib.Status.ALREADY_EXISTS: EntityAlreadyExists,\n            grpclib.Status.PERMISSION_DENIED: PermissionDenied,\n            grpclib.Status.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpclib.Status.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpclib.Status.ABORTED: OperationAborted,\n            grpclib.Status.OUT_OF_RANGE: OperationOutOfRange,\n            grpclib.Status.UNIMPLEMENTED: OperationNotImplemented,\n            grpclib.Status.INTERNAL: InternalError,\n            grpclib.Status.UNAVAILABLE: ServiceUnavailable,\n            grpclib.Status.DATA_LOSS: DataLoss,\n            grpclib.Status.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpclib_status_map.get(grpc_error.status):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    elif isinstance(grpc_error, _grpchacks.GrpcioError):\n        import grpc  # pylint: disable=import-outside-toplevel\n\n        grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n            grpc.StatusCode.CANCELLED: OperationCancelled,\n            grpc.StatusCode.UNKNOWN: UnknownError,\n            grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n            grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpc.StatusCode.NOT_FOUND: EntityNotFound,\n            grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n            grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n            grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpc.StatusCode.ABORTED: OperationAborted,\n            grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n            grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n            grpc.StatusCode.INTERNAL: InternalError,\n            grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n            grpc.StatusCode.DATA_LOSS: DataLoss,\n            grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpc_status_map.get(grpc_error.code()):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.PermissionDenied","title":"frequenz.client.base.exception.PermissionDenied","text":"<p>               Bases: <code>GrpcError</code></p> <p>The caller does not have permission to execute the specified operation.</p> <p>Note that when the operation is rejected due to other reasons, such as the resources being exhausted or the user not being authenticated at all, different errors should be catched instead (ResourceExhausted and OperationUnauthenticated respectively).</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class PermissionDenied(GrpcError):\n    \"\"\"The caller does not have permission to execute the specified operation.\n\n    Note that when the operation is rejected due to other reasons, such as the resources\n    being exhausted or the user not being authenticated at all, different errors should\n    be catched instead\n    ([ResourceExhausted][frequenz.client.base.exception.ResourceExhausted] and\n    [OperationUnauthenticated][frequenz.client.base.exception.OperationUnauthenticated]\n    respectively).\n    \"\"\"\n\n    def __init__(\n        self, *, server_url: str, operation: str, grpc_error: Exception\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error originating this exception.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"The caller does not have permission to execute the specified \"\n            \"operation\",\n            grpc_error=grpc_error,\n            retryable=True,  # If the user is granted permission it might succeed\n        )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.PermissionDenied-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.PermissionDenied.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.PermissionDenied.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error = grpc_error\n</code></pre> <p>The original gRPC error.</p> <p>This is either a <code>grpclib.GRPCError</code> or a <code>grpc.aio.AioRpcError</code> depending on which library is used. We can't type this correctly if we want this library to work when only one of the libraries is installed.</p> Tip <p>If you need to get this error for a particular library, use the appropriate property:</p> <ul> <li>grpclib_error   for <code>grpclib.GRPCError</code></li> <li>grpcio_error for   <code>grpc.aio.AioRpcError</code></li> </ul>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.PermissionDenied.grpcio_error","title":"grpcio_error  <code>property</code>","text":"<pre><code>grpcio_error: GrpcioError\n</code></pre> <p>The original <code>grpc.aio.AioRpcError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.PermissionDenied.grpclib_error","title":"grpclib_error  <code>property</code>","text":"<pre><code>grpclib_error: GrpclibError\n</code></pre> <p>The original <code>grpclib.GRPCError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.PermissionDenied.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.PermissionDenied.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.PermissionDenied.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.PermissionDenied-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.PermissionDenied.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>Exception</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self, *, server_url: str, operation: str, grpc_error: Exception\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error originating this exception.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"The caller does not have permission to execute the specified \"\n        \"operation\",\n        grpc_error=grpc_error,\n        retryable=True,  # If the user is granted permission it might succeed\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.PermissionDenied.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>Exception</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: Exception\n        ) -&gt; GrpcError: ...\n\n    if isinstance(grpc_error, _grpchacks.GrpclibError):\n        import grpclib  # pylint: disable=import-outside-toplevel\n\n        grpclib_status_map: dict[grpclib.Status, Ctor] = {\n            grpclib.Status.CANCELLED: OperationCancelled,\n            grpclib.Status.UNKNOWN: UnknownError,\n            grpclib.Status.INVALID_ARGUMENT: InvalidArgument,\n            grpclib.Status.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpclib.Status.NOT_FOUND: EntityNotFound,\n            grpclib.Status.ALREADY_EXISTS: EntityAlreadyExists,\n            grpclib.Status.PERMISSION_DENIED: PermissionDenied,\n            grpclib.Status.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpclib.Status.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpclib.Status.ABORTED: OperationAborted,\n            grpclib.Status.OUT_OF_RANGE: OperationOutOfRange,\n            grpclib.Status.UNIMPLEMENTED: OperationNotImplemented,\n            grpclib.Status.INTERNAL: InternalError,\n            grpclib.Status.UNAVAILABLE: ServiceUnavailable,\n            grpclib.Status.DATA_LOSS: DataLoss,\n            grpclib.Status.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpclib_status_map.get(grpc_error.status):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    elif isinstance(grpc_error, _grpchacks.GrpcioError):\n        import grpc  # pylint: disable=import-outside-toplevel\n\n        grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n            grpc.StatusCode.CANCELLED: OperationCancelled,\n            grpc.StatusCode.UNKNOWN: UnknownError,\n            grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n            grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpc.StatusCode.NOT_FOUND: EntityNotFound,\n            grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n            grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n            grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpc.StatusCode.ABORTED: OperationAborted,\n            grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n            grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n            grpc.StatusCode.INTERNAL: InternalError,\n            grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n            grpc.StatusCode.DATA_LOSS: DataLoss,\n            grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpc_status_map.get(grpc_error.code()):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ResourceExhausted","title":"frequenz.client.base.exception.ResourceExhausted","text":"<p>               Bases: <code>GrpcError</code></p> <p>Some resource has been exhausted (for example per-user quota, disk space, etc.).</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class ResourceExhausted(GrpcError):\n    \"\"\"Some resource has been exhausted (for example per-user quota, disk space, etc.).\"\"\"\n\n    def __init__(\n        self, *, server_url: str, operation: str, grpc_error: Exception\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error originating this exception.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"Some resource has been exhausted (for example per-user quota, \"\n            \"disk space, etc.)\",\n            grpc_error=grpc_error,\n            retryable=True,  # If the resource is freed it might succeed\n        )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ResourceExhausted-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ResourceExhausted.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ResourceExhausted.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error = grpc_error\n</code></pre> <p>The original gRPC error.</p> <p>This is either a <code>grpclib.GRPCError</code> or a <code>grpc.aio.AioRpcError</code> depending on which library is used. We can't type this correctly if we want this library to work when only one of the libraries is installed.</p> Tip <p>If you need to get this error for a particular library, use the appropriate property:</p> <ul> <li>grpclib_error   for <code>grpclib.GRPCError</code></li> <li>grpcio_error for   <code>grpc.aio.AioRpcError</code></li> </ul>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ResourceExhausted.grpcio_error","title":"grpcio_error  <code>property</code>","text":"<pre><code>grpcio_error: GrpcioError\n</code></pre> <p>The original <code>grpc.aio.AioRpcError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ResourceExhausted.grpclib_error","title":"grpclib_error  <code>property</code>","text":"<pre><code>grpclib_error: GrpclibError\n</code></pre> <p>The original <code>grpclib.GRPCError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ResourceExhausted.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ResourceExhausted.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ResourceExhausted.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ResourceExhausted-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ResourceExhausted.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>Exception</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self, *, server_url: str, operation: str, grpc_error: Exception\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error originating this exception.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"Some resource has been exhausted (for example per-user quota, \"\n        \"disk space, etc.)\",\n        grpc_error=grpc_error,\n        retryable=True,  # If the resource is freed it might succeed\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ResourceExhausted.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>Exception</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: Exception\n        ) -&gt; GrpcError: ...\n\n    if isinstance(grpc_error, _grpchacks.GrpclibError):\n        import grpclib  # pylint: disable=import-outside-toplevel\n\n        grpclib_status_map: dict[grpclib.Status, Ctor] = {\n            grpclib.Status.CANCELLED: OperationCancelled,\n            grpclib.Status.UNKNOWN: UnknownError,\n            grpclib.Status.INVALID_ARGUMENT: InvalidArgument,\n            grpclib.Status.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpclib.Status.NOT_FOUND: EntityNotFound,\n            grpclib.Status.ALREADY_EXISTS: EntityAlreadyExists,\n            grpclib.Status.PERMISSION_DENIED: PermissionDenied,\n            grpclib.Status.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpclib.Status.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpclib.Status.ABORTED: OperationAborted,\n            grpclib.Status.OUT_OF_RANGE: OperationOutOfRange,\n            grpclib.Status.UNIMPLEMENTED: OperationNotImplemented,\n            grpclib.Status.INTERNAL: InternalError,\n            grpclib.Status.UNAVAILABLE: ServiceUnavailable,\n            grpclib.Status.DATA_LOSS: DataLoss,\n            grpclib.Status.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpclib_status_map.get(grpc_error.status):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    elif isinstance(grpc_error, _grpchacks.GrpcioError):\n        import grpc  # pylint: disable=import-outside-toplevel\n\n        grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n            grpc.StatusCode.CANCELLED: OperationCancelled,\n            grpc.StatusCode.UNKNOWN: UnknownError,\n            grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n            grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpc.StatusCode.NOT_FOUND: EntityNotFound,\n            grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n            grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n            grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpc.StatusCode.ABORTED: OperationAborted,\n            grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n            grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n            grpc.StatusCode.INTERNAL: InternalError,\n            grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n            grpc.StatusCode.DATA_LOSS: DataLoss,\n            grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpc_status_map.get(grpc_error.code()):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ServiceUnavailable","title":"frequenz.client.base.exception.ServiceUnavailable","text":"<p>               Bases: <code>GrpcError</code></p> <p>The service is currently unavailable.</p> <p>This is most likely a transient condition, which can be corrected by retrying with a backoff. Note that it is not always safe to retry non-idempotent operations.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class ServiceUnavailable(GrpcError):\n    \"\"\"The service is currently unavailable.\n\n    This is most likely a transient condition, which can be corrected by retrying with\n    a backoff. Note that it is not always safe to retry non-idempotent operations.\n    \"\"\"\n\n    def __init__(\n        self, *, server_url: str, operation: str, grpc_error: Exception\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error originating this exception.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"The service is currently unavailable\",\n            grpc_error=grpc_error,\n            retryable=True,  # If the service becomes available it might succeed\n        )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ServiceUnavailable-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ServiceUnavailable.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ServiceUnavailable.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error = grpc_error\n</code></pre> <p>The original gRPC error.</p> <p>This is either a <code>grpclib.GRPCError</code> or a <code>grpc.aio.AioRpcError</code> depending on which library is used. We can't type this correctly if we want this library to work when only one of the libraries is installed.</p> Tip <p>If you need to get this error for a particular library, use the appropriate property:</p> <ul> <li>grpclib_error   for <code>grpclib.GRPCError</code></li> <li>grpcio_error for   <code>grpc.aio.AioRpcError</code></li> </ul>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ServiceUnavailable.grpcio_error","title":"grpcio_error  <code>property</code>","text":"<pre><code>grpcio_error: GrpcioError\n</code></pre> <p>The original <code>grpc.aio.AioRpcError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ServiceUnavailable.grpclib_error","title":"grpclib_error  <code>property</code>","text":"<pre><code>grpclib_error: GrpclibError\n</code></pre> <p>The original <code>grpclib.GRPCError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ServiceUnavailable.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ServiceUnavailable.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ServiceUnavailable.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ServiceUnavailable-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ServiceUnavailable.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>Exception</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self, *, server_url: str, operation: str, grpc_error: Exception\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error originating this exception.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"The service is currently unavailable\",\n        grpc_error=grpc_error,\n        retryable=True,  # If the service becomes available it might succeed\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.ServiceUnavailable.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>Exception</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: Exception\n        ) -&gt; GrpcError: ...\n\n    if isinstance(grpc_error, _grpchacks.GrpclibError):\n        import grpclib  # pylint: disable=import-outside-toplevel\n\n        grpclib_status_map: dict[grpclib.Status, Ctor] = {\n            grpclib.Status.CANCELLED: OperationCancelled,\n            grpclib.Status.UNKNOWN: UnknownError,\n            grpclib.Status.INVALID_ARGUMENT: InvalidArgument,\n            grpclib.Status.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpclib.Status.NOT_FOUND: EntityNotFound,\n            grpclib.Status.ALREADY_EXISTS: EntityAlreadyExists,\n            grpclib.Status.PERMISSION_DENIED: PermissionDenied,\n            grpclib.Status.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpclib.Status.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpclib.Status.ABORTED: OperationAborted,\n            grpclib.Status.OUT_OF_RANGE: OperationOutOfRange,\n            grpclib.Status.UNIMPLEMENTED: OperationNotImplemented,\n            grpclib.Status.INTERNAL: InternalError,\n            grpclib.Status.UNAVAILABLE: ServiceUnavailable,\n            grpclib.Status.DATA_LOSS: DataLoss,\n            grpclib.Status.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpclib_status_map.get(grpc_error.status):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    elif isinstance(grpc_error, _grpchacks.GrpcioError):\n        import grpc  # pylint: disable=import-outside-toplevel\n\n        grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n            grpc.StatusCode.CANCELLED: OperationCancelled,\n            grpc.StatusCode.UNKNOWN: UnknownError,\n            grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n            grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpc.StatusCode.NOT_FOUND: EntityNotFound,\n            grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n            grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n            grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpc.StatusCode.ABORTED: OperationAborted,\n            grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n            grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n            grpc.StatusCode.INTERNAL: InternalError,\n            grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n            grpc.StatusCode.DATA_LOSS: DataLoss,\n            grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpc_status_map.get(grpc_error.code()):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.UnknownError","title":"frequenz.client.base.exception.UnknownError","text":"<p>               Bases: <code>GrpcError</code></p> <p>There was an error that can't be described using other statuses.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class UnknownError(GrpcError):\n    \"\"\"There was an error that can't be described using other statuses.\"\"\"\n\n    def __init__(\n        self, *, server_url: str, operation: str, grpc_error: Exception\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error originating this exception.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"There was an error that can't be described using other statuses\",\n            grpc_error=grpc_error,\n            retryable=True,  # We don't know so we assume it's retryable\n        )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.UnknownError-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.UnknownError.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.UnknownError.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error = grpc_error\n</code></pre> <p>The original gRPC error.</p> <p>This is either a <code>grpclib.GRPCError</code> or a <code>grpc.aio.AioRpcError</code> depending on which library is used. We can't type this correctly if we want this library to work when only one of the libraries is installed.</p> Tip <p>If you need to get this error for a particular library, use the appropriate property:</p> <ul> <li>grpclib_error   for <code>grpclib.GRPCError</code></li> <li>grpcio_error for   <code>grpc.aio.AioRpcError</code></li> </ul>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.UnknownError.grpcio_error","title":"grpcio_error  <code>property</code>","text":"<pre><code>grpcio_error: GrpcioError\n</code></pre> <p>The original <code>grpc.aio.AioRpcError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.UnknownError.grpclib_error","title":"grpclib_error  <code>property</code>","text":"<pre><code>grpclib_error: GrpclibError\n</code></pre> <p>The original <code>grpclib.GRPCError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.UnknownError.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.UnknownError.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.UnknownError.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.UnknownError-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.UnknownError.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>Exception</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self, *, server_url: str, operation: str, grpc_error: Exception\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error originating this exception.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"There was an error that can't be described using other statuses\",\n        grpc_error=grpc_error,\n        retryable=True,  # We don't know so we assume it's retryable\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.UnknownError.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>Exception</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: Exception\n        ) -&gt; GrpcError: ...\n\n    if isinstance(grpc_error, _grpchacks.GrpclibError):\n        import grpclib  # pylint: disable=import-outside-toplevel\n\n        grpclib_status_map: dict[grpclib.Status, Ctor] = {\n            grpclib.Status.CANCELLED: OperationCancelled,\n            grpclib.Status.UNKNOWN: UnknownError,\n            grpclib.Status.INVALID_ARGUMENT: InvalidArgument,\n            grpclib.Status.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpclib.Status.NOT_FOUND: EntityNotFound,\n            grpclib.Status.ALREADY_EXISTS: EntityAlreadyExists,\n            grpclib.Status.PERMISSION_DENIED: PermissionDenied,\n            grpclib.Status.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpclib.Status.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpclib.Status.ABORTED: OperationAborted,\n            grpclib.Status.OUT_OF_RANGE: OperationOutOfRange,\n            grpclib.Status.UNIMPLEMENTED: OperationNotImplemented,\n            grpclib.Status.INTERNAL: InternalError,\n            grpclib.Status.UNAVAILABLE: ServiceUnavailable,\n            grpclib.Status.DATA_LOSS: DataLoss,\n            grpclib.Status.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpclib_status_map.get(grpc_error.status):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    elif isinstance(grpc_error, _grpchacks.GrpcioError):\n        import grpc  # pylint: disable=import-outside-toplevel\n\n        grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n            grpc.StatusCode.CANCELLED: OperationCancelled,\n            grpc.StatusCode.UNKNOWN: UnknownError,\n            grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n            grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpc.StatusCode.NOT_FOUND: EntityNotFound,\n            grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n            grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n            grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpc.StatusCode.ABORTED: OperationAborted,\n            grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n            grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n            grpc.StatusCode.INTERNAL: InternalError,\n            grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n            grpc.StatusCode.DATA_LOSS: DataLoss,\n            grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpc_status_map.get(grpc_error.code()):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.UnrecognizedGrpcStatus","title":"frequenz.client.base.exception.UnrecognizedGrpcStatus","text":"<p>               Bases: <code>GrpcError</code></p> <p>The gRPC server returned an unrecognized status code.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class UnrecognizedGrpcStatus(GrpcError):\n    \"\"\"The gRPC server returned an unrecognized status code.\"\"\"\n\n    def __init__(\n        self, *, server_url: str, operation: str, grpc_error: Exception\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error originating this exception.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"Got an unrecognized status code\",\n            grpc_error=grpc_error,\n            retryable=True,  # We don't know so we assume it's retryable\n        )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.UnrecognizedGrpcStatus-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.UnrecognizedGrpcStatus.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.UnrecognizedGrpcStatus.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error = grpc_error\n</code></pre> <p>The original gRPC error.</p> <p>This is either a <code>grpclib.GRPCError</code> or a <code>grpc.aio.AioRpcError</code> depending on which library is used. We can't type this correctly if we want this library to work when only one of the libraries is installed.</p> Tip <p>If you need to get this error for a particular library, use the appropriate property:</p> <ul> <li>grpclib_error   for <code>grpclib.GRPCError</code></li> <li>grpcio_error for   <code>grpc.aio.AioRpcError</code></li> </ul>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.UnrecognizedGrpcStatus.grpcio_error","title":"grpcio_error  <code>property</code>","text":"<pre><code>grpcio_error: GrpcioError\n</code></pre> <p>The original <code>grpc.aio.AioRpcError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.UnrecognizedGrpcStatus.grpclib_error","title":"grpclib_error  <code>property</code>","text":"<pre><code>grpclib_error: GrpclibError\n</code></pre> <p>The original <code>grpclib.GRPCError</code>.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.UnrecognizedGrpcStatus.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.UnrecognizedGrpcStatus.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.UnrecognizedGrpcStatus.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.UnrecognizedGrpcStatus-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.UnrecognizedGrpcStatus.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>Exception</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self, *, server_url: str, operation: str, grpc_error: Exception\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error originating this exception.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"Got an unrecognized status code\",\n        grpc_error=grpc_error,\n        retryable=True,  # We don't know so we assume it's retryable\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/exception/#frequenz.client.base.exception.UnrecognizedGrpcStatus.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>Exception</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: Exception,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: Exception\n        ) -&gt; GrpcError: ...\n\n    if isinstance(grpc_error, _grpchacks.GrpclibError):\n        import grpclib  # pylint: disable=import-outside-toplevel\n\n        grpclib_status_map: dict[grpclib.Status, Ctor] = {\n            grpclib.Status.CANCELLED: OperationCancelled,\n            grpclib.Status.UNKNOWN: UnknownError,\n            grpclib.Status.INVALID_ARGUMENT: InvalidArgument,\n            grpclib.Status.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpclib.Status.NOT_FOUND: EntityNotFound,\n            grpclib.Status.ALREADY_EXISTS: EntityAlreadyExists,\n            grpclib.Status.PERMISSION_DENIED: PermissionDenied,\n            grpclib.Status.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpclib.Status.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpclib.Status.ABORTED: OperationAborted,\n            grpclib.Status.OUT_OF_RANGE: OperationOutOfRange,\n            grpclib.Status.UNIMPLEMENTED: OperationNotImplemented,\n            grpclib.Status.INTERNAL: InternalError,\n            grpclib.Status.UNAVAILABLE: ServiceUnavailable,\n            grpclib.Status.DATA_LOSS: DataLoss,\n            grpclib.Status.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpclib_status_map.get(grpc_error.status):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    elif isinstance(grpc_error, _grpchacks.GrpcioError):\n        import grpc  # pylint: disable=import-outside-toplevel\n\n        grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n            grpc.StatusCode.CANCELLED: OperationCancelled,\n            grpc.StatusCode.UNKNOWN: UnknownError,\n            grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n            grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpc.StatusCode.NOT_FOUND: EntityNotFound,\n            grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n            grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n            grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpc.StatusCode.ABORTED: OperationAborted,\n            grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n            grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n            grpc.StatusCode.INTERNAL: InternalError,\n            grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n            grpc.StatusCode.DATA_LOSS: DataLoss,\n            grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpc_status_map.get(grpc_error.code()):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/","title":"retry","text":""},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry","title":"frequenz.client.base.retry","text":"<p>Implementations for retry strategies.</p>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.DEFAULT_RETRY_INTERVAL","title":"frequenz.client.base.retry.DEFAULT_RETRY_INTERVAL  <code>module-attribute</code>","text":"<pre><code>DEFAULT_RETRY_INTERVAL = 3.0\n</code></pre> <p>Default retry interval, in seconds.</p>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.DEFAULT_RETRY_JITTER","title":"frequenz.client.base.retry.DEFAULT_RETRY_JITTER  <code>module-attribute</code>","text":"<pre><code>DEFAULT_RETRY_JITTER = 1.0\n</code></pre> <p>Default retry jitter, in seconds.</p>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry-classes","title":"Classes","text":""},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.ExponentialBackoff","title":"frequenz.client.base.retry.ExponentialBackoff","text":"<p>               Bases: <code>Strategy</code></p> <p>Provides methods for calculating the exponential interval between retries.</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>class ExponentialBackoff(Strategy):\n    \"\"\"Provides methods for calculating the exponential interval between retries.\"\"\"\n\n    DEFAULT_INTERVAL = DEFAULT_RETRY_INTERVAL\n    \"\"\"Default retry interval, in seconds.\"\"\"\n\n    DEFAULT_MAX_INTERVAL = 60.0\n    \"\"\"Default maximum retry interval, in seconds.\"\"\"\n\n    DEFAULT_MULTIPLIER = 2.0\n    \"\"\"Default multiplier for exponential increment.\"\"\"\n\n    # pylint: disable=too-many-arguments\n    def __init__(\n        self,\n        initial_interval: float = DEFAULT_INTERVAL,\n        max_interval: float = DEFAULT_MAX_INTERVAL,\n        multiplier: float = DEFAULT_MULTIPLIER,\n        jitter: float = DEFAULT_RETRY_JITTER,\n        limit: int | None = None,\n    ) -&gt; None:\n        \"\"\"Create a `ExponentialBackoff` instance.\n\n        Args:\n            initial_interval: time to wait for before the first retry, in\n                seconds.\n            max_interval: maximum interval, in seconds.\n            multiplier: exponential increment for interval.\n            jitter: a jitter to add to the retry interval.\n            limit: max number of retries before giving up.  `None` means no\n                limit, and `0` means no retry.\n        \"\"\"\n        self._initial = initial_interval\n        self._max = max_interval\n        self._multiplier = multiplier\n        self._jitter = jitter\n        self._limit = limit\n\n        self._count = 0\n\n    def next_interval(self) -&gt; float | None:\n        \"\"\"Return the time to wait before the next retry.\n\n        Returns `None` if the retry limit has been reached, and no more retries\n        are possible.\n\n        Returns:\n            Time until next retry when below retry limit, and None otherwise.\n        \"\"\"\n        if self._limit is not None and self._count &gt;= self._limit:\n            return None\n        self._count += 1\n        exp_backoff_interval = self._initial * self._multiplier ** (self._count - 1)\n        return min(exp_backoff_interval + random.uniform(0.0, self._jitter), self._max)\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.ExponentialBackoff-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.ExponentialBackoff.DEFAULT_INTERVAL","title":"DEFAULT_INTERVAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEFAULT_INTERVAL = DEFAULT_RETRY_INTERVAL\n</code></pre> <p>Default retry interval, in seconds.</p>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.ExponentialBackoff.DEFAULT_MAX_INTERVAL","title":"DEFAULT_MAX_INTERVAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEFAULT_MAX_INTERVAL = 60.0\n</code></pre> <p>Default maximum retry interval, in seconds.</p>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.ExponentialBackoff.DEFAULT_MULTIPLIER","title":"DEFAULT_MULTIPLIER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEFAULT_MULTIPLIER = 2.0\n</code></pre> <p>Default multiplier for exponential increment.</p>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.ExponentialBackoff-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.ExponentialBackoff.__init__","title":"__init__","text":"<pre><code>__init__(\n    initial_interval: float = DEFAULT_INTERVAL,\n    max_interval: float = DEFAULT_MAX_INTERVAL,\n    multiplier: float = DEFAULT_MULTIPLIER,\n    jitter: float = DEFAULT_RETRY_JITTER,\n    limit: int | None = None,\n) -&gt; None\n</code></pre> <p>Create a <code>ExponentialBackoff</code> instance.</p> PARAMETER DESCRIPTION <code>initial_interval</code> <p>time to wait for before the first retry, in seconds.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_INTERVAL</code> </p> <code>max_interval</code> <p>maximum interval, in seconds.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_MAX_INTERVAL</code> </p> <code>multiplier</code> <p>exponential increment for interval.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_MULTIPLIER</code> </p> <code>jitter</code> <p>a jitter to add to the retry interval.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_RETRY_JITTER</code> </p> <code>limit</code> <p>max number of retries before giving up.  <code>None</code> means no limit, and <code>0</code> means no retry.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>def __init__(\n    self,\n    initial_interval: float = DEFAULT_INTERVAL,\n    max_interval: float = DEFAULT_MAX_INTERVAL,\n    multiplier: float = DEFAULT_MULTIPLIER,\n    jitter: float = DEFAULT_RETRY_JITTER,\n    limit: int | None = None,\n) -&gt; None:\n    \"\"\"Create a `ExponentialBackoff` instance.\n\n    Args:\n        initial_interval: time to wait for before the first retry, in\n            seconds.\n        max_interval: maximum interval, in seconds.\n        multiplier: exponential increment for interval.\n        jitter: a jitter to add to the retry interval.\n        limit: max number of retries before giving up.  `None` means no\n            limit, and `0` means no retry.\n    \"\"\"\n    self._initial = initial_interval\n    self._max = max_interval\n    self._multiplier = multiplier\n    self._jitter = jitter\n    self._limit = limit\n\n    self._count = 0\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.ExponentialBackoff.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[float]\n</code></pre> <p>Return an iterator over the retry intervals.</p> YIELDS DESCRIPTION <code>float</code> <p>Next retry interval in seconds.</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>def __iter__(self) -&gt; Iterator[float]:\n    \"\"\"Return an iterator over the retry intervals.\n\n    Yields:\n        Next retry interval in seconds.\n    \"\"\"\n    while True:\n        interval = self.next_interval()\n        if interval is None:\n            break\n        yield interval\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.ExponentialBackoff.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> <p>Create a new instance of <code>self</code>.</p> RETURNS DESCRIPTION <code>Self</code> <p>A deepcopy of <code>self</code>.</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Create a new instance of `self`.\n\n    Returns:\n        A deepcopy of `self`.\n    \"\"\"\n    ret = deepcopy(self)\n    ret.reset()\n    return ret\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.ExponentialBackoff.get_progress","title":"get_progress","text":"<pre><code>get_progress() -&gt; str\n</code></pre> <p>Return a string denoting the retry progress.</p> RETURNS DESCRIPTION <code>str</code> <p>String denoting retry progress in the form \"(count/limit)\"</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>def get_progress(self) -&gt; str:\n    \"\"\"Return a string denoting the retry progress.\n\n    Returns:\n        String denoting retry progress in the form \"(count/limit)\"\n    \"\"\"\n    if self._limit is None:\n        return f\"({self._count}/\u221e)\"\n\n    return f\"({self._count}/{self._limit})\"\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.ExponentialBackoff.next_interval","title":"next_interval","text":"<pre><code>next_interval() -&gt; float | None\n</code></pre> <p>Return the time to wait before the next retry.</p> <p>Returns <code>None</code> if the retry limit has been reached, and no more retries are possible.</p> RETURNS DESCRIPTION <code>float | None</code> <p>Time until next retry when below retry limit, and None otherwise.</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>def next_interval(self) -&gt; float | None:\n    \"\"\"Return the time to wait before the next retry.\n\n    Returns `None` if the retry limit has been reached, and no more retries\n    are possible.\n\n    Returns:\n        Time until next retry when below retry limit, and None otherwise.\n    \"\"\"\n    if self._limit is not None and self._count &gt;= self._limit:\n        return None\n    self._count += 1\n    exp_backoff_interval = self._initial * self._multiplier ** (self._count - 1)\n    return min(exp_backoff_interval + random.uniform(0.0, self._jitter), self._max)\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.ExponentialBackoff.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Reset the retry counter.</p> <p>To be called as soon as a connection is successful.</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset the retry counter.\n\n    To be called as soon as a connection is successful.\n    \"\"\"\n    self._count = 0\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.LinearBackoff","title":"frequenz.client.base.retry.LinearBackoff","text":"<p>               Bases: <code>Strategy</code></p> <p>Provides methods for calculating the interval between retries.</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>class LinearBackoff(Strategy):\n    \"\"\"Provides methods for calculating the interval between retries.\"\"\"\n\n    def __init__(\n        self,\n        interval: float = DEFAULT_RETRY_INTERVAL,\n        jitter: float = DEFAULT_RETRY_JITTER,\n        limit: int | None = None,\n    ) -&gt; None:\n        \"\"\"Create a `LinearBackoff` instance.\n\n        Args:\n            interval: time to wait for before the next retry, in seconds.\n            jitter: a jitter to add to the retry interval.\n            limit: max number of retries before giving up.  `None` means no\n                limit, and `0` means no retry.\n        \"\"\"\n        self._interval = interval\n        self._jitter = jitter\n        self._limit = limit\n\n        self._count = 0\n\n    def next_interval(self) -&gt; float | None:\n        \"\"\"Return the time to wait before the next retry.\n\n        Returns `None` if the retry limit has been reached, and no more retries\n        are possible.\n\n        Returns:\n            Time until next retry when below retry limit, and None otherwise.\n        \"\"\"\n        if self._limit is not None and self._count &gt;= self._limit:\n            return None\n        self._count += 1\n        return self._interval + random.uniform(0.0, self._jitter)\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.LinearBackoff-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.LinearBackoff.__init__","title":"__init__","text":"<pre><code>__init__(\n    interval: float = DEFAULT_RETRY_INTERVAL,\n    jitter: float = DEFAULT_RETRY_JITTER,\n    limit: int | None = None,\n) -&gt; None\n</code></pre> <p>Create a <code>LinearBackoff</code> instance.</p> PARAMETER DESCRIPTION <code>interval</code> <p>time to wait for before the next retry, in seconds.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_RETRY_INTERVAL</code> </p> <code>jitter</code> <p>a jitter to add to the retry interval.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_RETRY_JITTER</code> </p> <code>limit</code> <p>max number of retries before giving up.  <code>None</code> means no limit, and <code>0</code> means no retry.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>def __init__(\n    self,\n    interval: float = DEFAULT_RETRY_INTERVAL,\n    jitter: float = DEFAULT_RETRY_JITTER,\n    limit: int | None = None,\n) -&gt; None:\n    \"\"\"Create a `LinearBackoff` instance.\n\n    Args:\n        interval: time to wait for before the next retry, in seconds.\n        jitter: a jitter to add to the retry interval.\n        limit: max number of retries before giving up.  `None` means no\n            limit, and `0` means no retry.\n    \"\"\"\n    self._interval = interval\n    self._jitter = jitter\n    self._limit = limit\n\n    self._count = 0\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.LinearBackoff.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[float]\n</code></pre> <p>Return an iterator over the retry intervals.</p> YIELDS DESCRIPTION <code>float</code> <p>Next retry interval in seconds.</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>def __iter__(self) -&gt; Iterator[float]:\n    \"\"\"Return an iterator over the retry intervals.\n\n    Yields:\n        Next retry interval in seconds.\n    \"\"\"\n    while True:\n        interval = self.next_interval()\n        if interval is None:\n            break\n        yield interval\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.LinearBackoff.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> <p>Create a new instance of <code>self</code>.</p> RETURNS DESCRIPTION <code>Self</code> <p>A deepcopy of <code>self</code>.</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Create a new instance of `self`.\n\n    Returns:\n        A deepcopy of `self`.\n    \"\"\"\n    ret = deepcopy(self)\n    ret.reset()\n    return ret\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.LinearBackoff.get_progress","title":"get_progress","text":"<pre><code>get_progress() -&gt; str\n</code></pre> <p>Return a string denoting the retry progress.</p> RETURNS DESCRIPTION <code>str</code> <p>String denoting retry progress in the form \"(count/limit)\"</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>def get_progress(self) -&gt; str:\n    \"\"\"Return a string denoting the retry progress.\n\n    Returns:\n        String denoting retry progress in the form \"(count/limit)\"\n    \"\"\"\n    if self._limit is None:\n        return f\"({self._count}/\u221e)\"\n\n    return f\"({self._count}/{self._limit})\"\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.LinearBackoff.next_interval","title":"next_interval","text":"<pre><code>next_interval() -&gt; float | None\n</code></pre> <p>Return the time to wait before the next retry.</p> <p>Returns <code>None</code> if the retry limit has been reached, and no more retries are possible.</p> RETURNS DESCRIPTION <code>float | None</code> <p>Time until next retry when below retry limit, and None otherwise.</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>def next_interval(self) -&gt; float | None:\n    \"\"\"Return the time to wait before the next retry.\n\n    Returns `None` if the retry limit has been reached, and no more retries\n    are possible.\n\n    Returns:\n        Time until next retry when below retry limit, and None otherwise.\n    \"\"\"\n    if self._limit is not None and self._count &gt;= self._limit:\n        return None\n    self._count += 1\n    return self._interval + random.uniform(0.0, self._jitter)\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.LinearBackoff.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Reset the retry counter.</p> <p>To be called as soon as a connection is successful.</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset the retry counter.\n\n    To be called as soon as a connection is successful.\n    \"\"\"\n    self._count = 0\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.Strategy","title":"frequenz.client.base.retry.Strategy","text":"<p>               Bases: <code>ABC</code></p> <p>Interface for implementing retry strategies.</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>class Strategy(ABC):\n    \"\"\"Interface for implementing retry strategies.\"\"\"\n\n    _limit: int | None\n    _count: int\n\n    @abstractmethod\n    def next_interval(self) -&gt; float | None:\n        \"\"\"Return the time to wait before the next retry.\n\n        Returns `None` if the retry limit has been reached, and no more retries\n        are possible.\n\n        Returns:\n            Time until next retry when below retry limit, and None otherwise.\n        \"\"\"\n\n    def get_progress(self) -&gt; str:\n        \"\"\"Return a string denoting the retry progress.\n\n        Returns:\n            String denoting retry progress in the form \"(count/limit)\"\n        \"\"\"\n        if self._limit is None:\n            return f\"({self._count}/\u221e)\"\n\n        return f\"({self._count}/{self._limit})\"\n\n    def reset(self) -&gt; None:\n        \"\"\"Reset the retry counter.\n\n        To be called as soon as a connection is successful.\n        \"\"\"\n        self._count = 0\n\n    def copy(self) -&gt; Self:\n        \"\"\"Create a new instance of `self`.\n\n        Returns:\n            A deepcopy of `self`.\n        \"\"\"\n        ret = deepcopy(self)\n        ret.reset()\n        return ret\n\n    def __iter__(self) -&gt; Iterator[float]:\n        \"\"\"Return an iterator over the retry intervals.\n\n        Yields:\n            Next retry interval in seconds.\n        \"\"\"\n        while True:\n            interval = self.next_interval()\n            if interval is None:\n                break\n            yield interval\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.Strategy-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.Strategy.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[float]\n</code></pre> <p>Return an iterator over the retry intervals.</p> YIELDS DESCRIPTION <code>float</code> <p>Next retry interval in seconds.</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>def __iter__(self) -&gt; Iterator[float]:\n    \"\"\"Return an iterator over the retry intervals.\n\n    Yields:\n        Next retry interval in seconds.\n    \"\"\"\n    while True:\n        interval = self.next_interval()\n        if interval is None:\n            break\n        yield interval\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.Strategy.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> <p>Create a new instance of <code>self</code>.</p> RETURNS DESCRIPTION <code>Self</code> <p>A deepcopy of <code>self</code>.</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Create a new instance of `self`.\n\n    Returns:\n        A deepcopy of `self`.\n    \"\"\"\n    ret = deepcopy(self)\n    ret.reset()\n    return ret\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.Strategy.get_progress","title":"get_progress","text":"<pre><code>get_progress() -&gt; str\n</code></pre> <p>Return a string denoting the retry progress.</p> RETURNS DESCRIPTION <code>str</code> <p>String denoting retry progress in the form \"(count/limit)\"</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>def get_progress(self) -&gt; str:\n    \"\"\"Return a string denoting the retry progress.\n\n    Returns:\n        String denoting retry progress in the form \"(count/limit)\"\n    \"\"\"\n    if self._limit is None:\n        return f\"({self._count}/\u221e)\"\n\n    return f\"({self._count}/{self._limit})\"\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.Strategy.next_interval","title":"next_interval  <code>abstractmethod</code>","text":"<pre><code>next_interval() -&gt; float | None\n</code></pre> <p>Return the time to wait before the next retry.</p> <p>Returns <code>None</code> if the retry limit has been reached, and no more retries are possible.</p> RETURNS DESCRIPTION <code>float | None</code> <p>Time until next retry when below retry limit, and None otherwise.</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>@abstractmethod\ndef next_interval(self) -&gt; float | None:\n    \"\"\"Return the time to wait before the next retry.\n\n    Returns `None` if the retry limit has been reached, and no more retries\n    are possible.\n\n    Returns:\n        Time until next retry when below retry limit, and None otherwise.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.Strategy.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Reset the retry counter.</p> <p>To be called as soon as a connection is successful.</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset the retry counter.\n\n    To be called as soon as a connection is successful.\n    \"\"\"\n    self._count = 0\n</code></pre>"},{"location":"reference/frequenz/client/base/streaming/","title":"streaming","text":""},{"location":"reference/frequenz/client/base/streaming/#frequenz.client.base.streaming","title":"frequenz.client.base.streaming","text":"<p>Implementation of the grpc streaming helper.</p>"},{"location":"reference/frequenz/client/base/streaming/#frequenz.client.base.streaming-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/base/streaming/#frequenz.client.base.streaming.InputT","title":"frequenz.client.base.streaming.InputT  <code>module-attribute</code>","text":"<pre><code>InputT = TypeVar('InputT')\n</code></pre> <p>The input type of the stream.</p>"},{"location":"reference/frequenz/client/base/streaming/#frequenz.client.base.streaming.OutputT","title":"frequenz.client.base.streaming.OutputT  <code>module-attribute</code>","text":"<pre><code>OutputT = TypeVar('OutputT')\n</code></pre> <p>The output type of the stream.</p>"},{"location":"reference/frequenz/client/base/streaming/#frequenz.client.base.streaming-classes","title":"Classes","text":""},{"location":"reference/frequenz/client/base/streaming/#frequenz.client.base.streaming.GrpcStreamBroadcaster","title":"frequenz.client.base.streaming.GrpcStreamBroadcaster","text":"<p>               Bases: <code>Generic[InputT, OutputT]</code></p> <p>Helper class to handle grpc streaming methods.</p> Source code in <code>frequenz/client/base/streaming.py</code> <pre><code>class GrpcStreamBroadcaster(Generic[InputT, OutputT]):\n    \"\"\"Helper class to handle grpc streaming methods.\"\"\"\n\n    def __init__(\n        self,\n        stream_name: str,\n        stream_method: Callable[[], AsyncIterator[InputT]],\n        transform: Callable[[InputT], OutputT],\n        retry_strategy: retry.Strategy | None = None,\n    ):\n        \"\"\"Initialize the streaming helper.\n\n        Args:\n            stream_name: A name to identify the stream in the logs.\n            stream_method: A function that returns the grpc stream. This function is\n                called everytime the connection is lost and we want to retry.\n            transform: A function to transform the input type to the output type.\n            retry_strategy: The retry strategy to use, when the connection is lost. Defaults\n                to retries every 3 seconds, with a jitter of 1 second, indefinitely.\n        \"\"\"\n        self._stream_name = stream_name\n        self._stream_method = stream_method\n        self._transform = transform\n        self._retry_strategy = (\n            retry.LinearBackoff() if retry_strategy is None else retry_strategy.copy()\n        )\n\n        self._channel: channels.Broadcast[OutputT] = channels.Broadcast(\n            name=f\"GrpcStreamBroadcaster-{stream_name}\"\n        )\n        self._task = asyncio.create_task(self._run())\n\n    def new_receiver(self, maxsize: int = 50) -&gt; channels.Receiver[OutputT]:\n        \"\"\"Create a new receiver for the stream.\n\n        Args:\n            maxsize: The maximum number of messages to buffer.\n\n        Returns:\n            A new receiver.\n        \"\"\"\n        return self._channel.new_receiver(limit=maxsize)\n\n    async def stop(self) -&gt; None:\n        \"\"\"Stop the streaming helper.\"\"\"\n        if self._task.done():\n            return\n        self._task.cancel()\n        try:\n            await self._task\n        except asyncio.CancelledError:\n            pass\n        await self._channel.close()\n\n    async def _run(self) -&gt; None:\n        \"\"\"Run the streaming helper.\"\"\"\n        sender = self._channel.new_sender()\n\n        while True:\n            error: Exception | None = None\n            _logger.info(\"%s: starting to stream\", self._stream_name)\n            try:\n                call = self._stream_method()\n                async for msg in call:\n                    await sender.send(self._transform(msg))\n            except (GrpcioError, GrpclibError) as err:\n                error = err\n            error_str = f\"Error: {error}\" if error else \"Stream exhausted\"\n            interval = self._retry_strategy.next_interval()\n            if interval is None:\n                _logger.error(\n                    \"%s: connection ended, retry limit exceeded (%s), giving up. %s.\",\n                    self._stream_name,\n                    self._retry_strategy.get_progress(),\n                    error_str,\n                )\n                await self._channel.close()\n                break\n            _logger.warning(\n                \"%s: connection ended, retrying %s in %0.3f seconds. %s.\",\n                self._stream_name,\n                self._retry_strategy.get_progress(),\n                interval,\n                error_str,\n            )\n            await asyncio.sleep(interval)\n</code></pre>"},{"location":"reference/frequenz/client/base/streaming/#frequenz.client.base.streaming.GrpcStreamBroadcaster-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/streaming/#frequenz.client.base.streaming.GrpcStreamBroadcaster.__init__","title":"__init__","text":"<pre><code>__init__(\n    stream_name: str,\n    stream_method: Callable[[], AsyncIterator[InputT]],\n    transform: Callable[[InputT], OutputT],\n    retry_strategy: Strategy | None = None,\n)\n</code></pre> <p>Initialize the streaming helper.</p> PARAMETER DESCRIPTION <code>stream_name</code> <p>A name to identify the stream in the logs.</p> <p> TYPE: <code>str</code> </p> <code>stream_method</code> <p>A function that returns the grpc stream. This function is called everytime the connection is lost and we want to retry.</p> <p> TYPE: <code>Callable[[], AsyncIterator[InputT]]</code> </p> <code>transform</code> <p>A function to transform the input type to the output type.</p> <p> TYPE: <code>Callable[[InputT], OutputT]</code> </p> <code>retry_strategy</code> <p>The retry strategy to use, when the connection is lost. Defaults to retries every 3 seconds, with a jitter of 1 second, indefinitely.</p> <p> TYPE: <code>Strategy | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/client/base/streaming.py</code> <pre><code>def __init__(\n    self,\n    stream_name: str,\n    stream_method: Callable[[], AsyncIterator[InputT]],\n    transform: Callable[[InputT], OutputT],\n    retry_strategy: retry.Strategy | None = None,\n):\n    \"\"\"Initialize the streaming helper.\n\n    Args:\n        stream_name: A name to identify the stream in the logs.\n        stream_method: A function that returns the grpc stream. This function is\n            called everytime the connection is lost and we want to retry.\n        transform: A function to transform the input type to the output type.\n        retry_strategy: The retry strategy to use, when the connection is lost. Defaults\n            to retries every 3 seconds, with a jitter of 1 second, indefinitely.\n    \"\"\"\n    self._stream_name = stream_name\n    self._stream_method = stream_method\n    self._transform = transform\n    self._retry_strategy = (\n        retry.LinearBackoff() if retry_strategy is None else retry_strategy.copy()\n    )\n\n    self._channel: channels.Broadcast[OutputT] = channels.Broadcast(\n        name=f\"GrpcStreamBroadcaster-{stream_name}\"\n    )\n    self._task = asyncio.create_task(self._run())\n</code></pre>"},{"location":"reference/frequenz/client/base/streaming/#frequenz.client.base.streaming.GrpcStreamBroadcaster.new_receiver","title":"new_receiver","text":"<pre><code>new_receiver(maxsize: int = 50) -&gt; Receiver[OutputT]\n</code></pre> <p>Create a new receiver for the stream.</p> PARAMETER DESCRIPTION <code>maxsize</code> <p>The maximum number of messages to buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>50</code> </p> RETURNS DESCRIPTION <code>Receiver[OutputT]</code> <p>A new receiver.</p> Source code in <code>frequenz/client/base/streaming.py</code> <pre><code>def new_receiver(self, maxsize: int = 50) -&gt; channels.Receiver[OutputT]:\n    \"\"\"Create a new receiver for the stream.\n\n    Args:\n        maxsize: The maximum number of messages to buffer.\n\n    Returns:\n        A new receiver.\n    \"\"\"\n    return self._channel.new_receiver(limit=maxsize)\n</code></pre>"},{"location":"reference/frequenz/client/base/streaming/#frequenz.client.base.streaming.GrpcStreamBroadcaster.stop","title":"stop  <code>async</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop the streaming helper.</p> Source code in <code>frequenz/client/base/streaming.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stop the streaming helper.\"\"\"\n    if self._task.done():\n        return\n    self._task.cancel()\n    try:\n        await self._task\n    except asyncio.CancelledError:\n        pass\n    await self._channel.close()\n</code></pre>"}]}